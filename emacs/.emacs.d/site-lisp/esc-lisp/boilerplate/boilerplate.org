#+todo: TODO(t) VERIFY(v) PRINT(r) | OPTIONAL(o) HIATUS(h) DONE(d) CANCELED(c)
#+startup: content
* Introduction
#+NAME: license
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; boilerplate library - a home for useful, logically disparate functions
  ;; Copyright (C) <year>  <name of author>

  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program. If not, see <http://www.gnu.org/licenses/>.

  ;; Boilerplate Library
  ;; This library is for the code so straightforward that it doesn't
  ;; belong in my .emacs. Only tried-and-tested programs make it into
  ;; this vault.
#+END_SRC
* Hooks
Here are custom hooks esc appends to common exposed hooks.
Captain Hook. Hooks are great. Everybody should expose more hooks.
** prog-mode-hook
#+NAME: prog-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/prog-mode-hook nil
      "esc's code to \\[prog-mode-hook]."
      :type 'hook
      :options '((auto-revert-mode t)
                 (smerge-mode t))
      :group 'boil)

  ;;;###autoload
  (defun esc/prog-mode-hook ()
   "esc's hook to \\[prog-mode-hook]."
    (auto-revert-mode t)
    (smerge-mode t))
#+END_SRC
** minibuffer hooks
#+NAME: minibuffer-setup-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/minibuffer-setup-hook nil
    "esc's hook to run upon entering the minibuffer."
    :type         'hook
    :options      '(autopair-mode -1)
    :group        'boil)

  ;;;###autoload
  (defun esc/minibuffer-setup-hook ()
    "esc's hook to run whilst entering the minibuffer's domain."
    (autopair-mode -1)
    (define-key minibuffer-local-map (kbd "<escape>") nil))

  (defcustom esc/minibuffer-exit-hook nil
    "esc's hook to run upon exiting the minibuffer."
    :type         'hook
    :options      '()
    :group        'boil)

  ;;;###autoload
  (defun esc/minibuffer-exit-hook ()
    "esc's hook to run whilst exiting the minibuffer's domain."
    nil)
#+END_SRC

** c-mode-common-hook
#+NAME: c-mode-common-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/c-insert-ifdef-ndebug-printf-string nil
    "Debugging string to insert in \\[esc/c-insert-ifdef-ndebug-printf]."
    :type '(string)
    :options '("printf(\"%s \\n\", __FUNCTION__);")
    :group 'boil)
  (setq esc/c-insert-ifdef-ndebug-printf-string "printf(\"%s \\n\", __FUNCTION__);")

  (defcustom esc/c-mode-common-hook nil
    "esc's code to \\[c-mode-common-hook]."
    :type 'hook
    :options '((setq ff-always-in-other-window t)
               (setq ff-always-try-to-create nil)
               ;(idle-highlight t)
               (autoload 'disaster "disaster")
               (local-set-key (kbd "C-c d") 'disaster)
               (local-set-key (kbd "C-c o") 'ff-find-other-file)
               (local-set-key (kbd "C-M-;") 'esc/yank-displaced-doxygen-comment)
               (local-set-key (kbd "C-c d") 'esc/c-insert-ifdef-ndebug-printf)
               (c-turn-on-eldoc-mode))
    :group 'boil)

  ;;;###autoload
  (defun esc/c-mode-common-hook ()
    "esc's code to \\[c-mode-common-hook]."
    ;(idle-highlight t)
    (autoload 'disaster "disaster")
    (local-set-key (kbd "C-c d") 'disaster)
    (local-set-key (kbd "C-c o") 'ff-find-other-file)
    (local-set-key (kbd "C-c d") 'esc/c-insert-ifdef-ndebug-printf)
    (local-set-key (kbd "C-M-;") 'esc/yank-displaced-doxygen-comment)
    (local-set-key (kbd "C-M-S-u") 'esc/unroll-cc-arguments)
    (c-turn-on-eldoc-mode)
    (setq ff-always-in-other-window t
          ff-always-try-to-create nil))
#+END_SRC
** c++-mode-common-hook
#+NAME: c++-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
    (defcustom esc/c++-mode-hook nil
      "esc's code to \\[c++-mode-hook]."
      :type 'hook
      :options '((setq comment-start "/*")
                 (setq comment-end "*/"))
      :group 'boil)

    ;;;###autoload
    (defun esc/c++-mode-hook ()
      "esc's code to \\[c++-mode-hook]."
      (setq comment-start "/*"
            comment-end "*/"))
#+END_SRC
** emacs-lisp-mode-hook
#+NAME: emacs-lisp-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/emacs-lisp-mode-hook nil
    "esc's code to \\[emacs-lisp-mode-hook]."
    :type         'hook
    :options      '((turn-on-eldoc-mode))
    :group        'boil)

  ;;;###autoload
  (defun esc/emacs-lisp-mode-hook ()
    "esc's code to \\[emacs-lisp-mode-hook]."
    (turn-on-eldoc-mode))
#+END_SRC
** fundamental-mode-hook
#+NAME: fundamental-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/fundamental-mode-hook nil
    "esc's code to \\[fundamental-mode-hook]."
    :type         'hook
    :options      '((autopair-mode -1)
                    (flyspell-mode 1))
    :group        'boil)

  ;;;###autoload
  (defun esc/fundamental-mode-hook ()
    "esc's code to \\[fundamental-mode-hook]."
    (autopair-mode -1)
    (flyspell-mode 1))
#+END_SRC
** eshell-mode-hook
TODO: defcustom
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun esc/eshell-mode-hook ()
    (define-key eshell-mode-map (kbd "C-x C-p") 'eshell-previous-matching-input-from-input)
    (define-key eshell-mode-map (kbd "C-x C-n") 'eshell-next-matching-input-from-input)
    (when (require 'em-smart nil 'noerror)
      (setq eshell-where-to-jump 'begin
            eshell-review-quick-commands nil
            eshell-smart-space-goes-to-end t)))
#+END_SRC
** enh-ruby-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
    (defcustom esc/enh-ruby-mode-hook nil
      "esc's code to \\[enh-ruby-mode-hook]."
      :type         'hook
      :options      '((idle-highlight t))
      :group        'boil)

    ;;;###autoload
    (defun esc/enh-ruby-mode-hook ()
      "esc's code to \\[enh-ruby-mode-hook]."
      ;(idle-highlight t)
      )
#+END_SRC
** erc-mode-hook
#+NAME: erc-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/erc-mode-hook nil
    "esc's code to \\[erc-mode-hook]."
    :type         'hook
    :options      '((autopair-mode -1))
    :group        'boil)

  ;;;###autoload
  (defun esc/erc-mode-hook ()
    "esc's code to \\[erc-mode-hook]."
    (autopair-mode -1))
#+END_SRC
** comint-mode-hook
#+NAME: comint-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/comint-mode-hook nil
    "esc's code to \\[comint-mode-hook]."
    :type         'hook
    :options      '((define-key comint-mode-map "M-p" 'comint-previous-input)
                    (define-key comint-mode-map "M-S-p" 'ace-window))
    :group        'boil)

  ;;;###autoload
  (defun esc/comint-mode-hook ()
    "esc's code to \\[comint-mode-hook]."
    ;; TODO: find the active keymap in comint-mode
    (define-key comint-mode-map "M-p" 'comint-previous-input)
    (define-key comint-mode-map "M-S-p" 'ace-window))
#+END_SRC
** iedit-mode-hook
TODO: defcustom
#+NAME: iedit-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/iedit-mode-hook ()
    "esc's hook to \\[iedit-mode-hook]."
    (define-key iedit-mode-keymap (kbd "<RET>") 'iedit-mode) ;exit
    ;; Don't go overriding my M-x chord, you hear
    (define-key iedit-mode-keymap (kbd "C-'") 'execute-extended-command))
#+END_SRC

** org-mode-hook
TODO: defcustom
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/org-mode-hook()
    (org-indent-mode)
    (imenu-add-to-menubar "Imenu")
    (local-set-key (kbd "C-M-n") 'outline-next-visible-heading)
    (local-set-key (kbd "C-M-p") 'outline-previous-visible-heading)
    (local-set-key (kbd "C-c C-a") 'org-todo))
#+END_SRC
** big-fringe-mode-hook
TODO: defcustom
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/big-fringe-mode-hook ()
    ;; TODO: copy from ecrosson-mobl
    )
#+END_SRC
* Licenses
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/insert-short-gpl ()
    "Insert the short version of the GNU GPL v3."
    (interactive)
    (insert
     "<one line to give the program's name and a brief idea of what it does.>
  Copyright (C) <year>  <name of author>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
  "))
#+END_SRC

* Emacs+
I'm feelin' a little [[http://stackoverflow.com/a/18680600][Haskelly]]
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun combinations (&rest lists)
    "Return a list of all possible combinations of the elements of
  LISTS. Think applicative functors from Haskell."
    (if (car lists)
        (mapcan (lambda (inner-val)
                  (mapcar (lambda (outer-val)
                            (cons outer-val
                                  inner-val))
                          (car lists)))
                (apply #'combinations (cdr lists)))
      (list nil)))
#+END_SRC

[[http://whattheemacsd.com/key-bindings.el-03.html][Magnar]] said it best, here's one command I could not live without.
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun esc/pull-up-line (&optional arg)
    "Pull up ARG lines."
    (interactive "p")
    (dotimes (i arg)
      (join-line -1)))
#+END_SRC

Thanks to the prolific [[http://ergoemacs.org/emacs/modernization_upcase-word.html][Xah Lee]].
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun esc/toggle-letter-case ()
    "Toggle the letter case of current word or text selection.
    Toggles between: “all lower”, “Init Caps”, “ALL CAPS”."
    (interactive)
    (let (p1 p2 (deactivate-mark nil) (case-fold-search nil))
      (if (region-active-p)
          (setq p1 (region-beginning) p2 (region-end))
        (let ((bds (bounds-of-thing-at-point 'word) ) )
          (setq p1 (car bds) p2 (cdr bds)) ) )
      (when (not (eq last-command this-command))
        (save-excursion
          (goto-char p1)
          (cond
           ((looking-at "[[:lower:]][[:lower:]]")
            (put this-command 'state "all lower"))
           ((looking-at "[[:upper:]][[:upper:]]")
            (put this-command 'state "all caps"))
           ((looking-at "[[:upper:]][[:lower:]]")
            (put this-command 'state "init caps"))
           ((looking-at "[[:lower:]]")
            (put this-command 'state "all lower"))
           ((looking-at "[[:upper:]]")
            (put this-command 'state "all caps"))
           (t (put this-command 'state "all lower")))))
      (cond
       ((string= "all lower" (get this-command 'state))
        (upcase-initials-region p1 p2)
        (put this-command 'state "init caps"))
       ((string= "init caps" (get this-command 'state))
        (upcase-region p1 p2)
        (put this-command 'state "all caps"))
       ((string= "all caps" (get this-command 'state))
        (downcase-region p1 p2)
        (put this-command 'state "all lower")))))
#+END_SRC

[[http://emacsredux.com/blog/2015/01/18/clear-comint-buffers/][Clear comint buffers - Emacs Redux]]
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  (defun comint-clear-buffer ()
    (interactive)
    (let ((comint-buffer-maximum-size 0))
      (comint-truncate-buffer)))
#+END_SRC

Many thanks to [[http://www.emacswiki.org/emacs/DictMode][EmacsWiki]].
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun esc/dictionary-search ()
    (interactive)
    (require 'dictionary)
    (let ((word (current-word))
          (enable-recursive-minibuffers t)
          (val))
      (setq val (read-from-minibuffer
                 (concat "Word"
                         (when word
                           (concat " (" word ")"))
                         ": ")))
      (dictionary-new-search
       (cons (cond
              ((and (equal val "") word)
               word)
              ((> (length val) 0)
               val)
              (t
               (error "No word to lookup")))
             dictionary-default-dictionary))))
#+END_SRC

Courtesy of [[http://oremacs.com/2015/01/26/occur-dwim/][or emacs]].
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun occur-dwim ()
    "Call `occur' with a sane default.

  \\[occur-dwim] will offer as the default candidate:

  - the current region, if it's active
  - the current symbol, otherwise"
    (interactive)
    (push (if (region-active-p)
              (buffer-substring-no-properties
               (region-beginning)
               (region-end))
            (thing-at-point 'symbol))
          regexp-history)
    (call-interactively 'occur))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun esc/insert-numeric-sequence ()
    "Insert a sequence of numbers at point, separated by spaces. Inclusive."
    (interactive)
    (let ((begin (read-number "Begin: "))
          (end (read-number "End: ")))
      (dotimes (i (- (+ 1 end) begin))
        (insert (number-to-string (+ i begin)))
        (insert " "))))

  ;;;###autoload
  (defun esc/copy-line (&optional arg)
    "Copy current line in the kill ring."
    (interactive "p")
    (dotimes (i arg)
      (kill-ring-save (line-beginning-position)
                      (line-beginning-position 2)))
    (message "Line copied."))

  ;;;###autoload
  (defun esc/remove-dos-eol ()
    "Do not show ^M in files containing mixed UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))

  ;;;###autoload
  (defun esc/word-count (&optional begin end)
    "Count words bounded by mark and cursor; if no region defined, use buffer."
    (interactive "r")
    (let ((b (if mark-active begin (point-min)))
          (e (if mark-active end (point-max))))
      (message "Word count: %s" (how-many "\\w+" b e))))

  ;;;###autoload
  (defun esc/time ()
    "Insert string for the current esc/time formatted as '2:34 PM'."
    (interactive)
    (insert (format-time-string "%I:%M %p")))

  ;;;###autoload
  (defun esc/date ()
    "Insert string for today's esc/date nicely formatted in American style,
     e.g. Sunday September 17, 2000."
    (interactive)
    (let ((str "%A %B %e, %Y"))
      (if (called-interactively-p 'any)
          (insert (format-time-string str))
        (message (format-time-string str)))))

  ;;;###autoload
  (defun esc/insert-date (prefix)
    "Insert the current date. With prefix-argument, use ISO format. With
     two prefix arguments, write out the day and month name."
    (interactive "P")
    (let ((format (cond
                   ((not prefix) "%d.%m.%Y")
                   ((equal prefix '(4)) "%Y-%m-%d")
                   ((equal prefix '(16)) "%A, %d. %B %Y")))
          (system-time-locale "de_DE"))
      (insert (format-time-string format))))

  ;;;###autoload
  (defun esc/back-to-indentation-or-beginning ()
    "Returns the point to the beginning of the current line, or if
  already there, the beginning of text on the current line."
    (interactive)
    (let ((pt (point)))
      (beginning-of-line)
      (when (eq pt (point))
        (beginning-of-line-text))))

  ;;;###autoload
  (defun esc/increment-number-at-point (arg)
    "Increment the number at point. Can be prefaced with a multiplier."
    (interactive "p")
    (dotimes (i arg)
      (skip-chars-backward "0123456789")
      (or (looking-at "[[:digit:]]+")
          (error "No number at point"))
      (replace-match (number-to-string
                      (1+ (string-to-number (match-string 0)))))))

  ;;;###autoload
  (defun esc/delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))

  ;;;###autoload
  (defun esc/rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name new-name))))))

  ;;;###autoload
  (defun esc/get-buffers-matching-mode (mode)
    "Returns a list of buffers where their major-mode is equal to MODE."
    (let ((buffer-mode-matches '()))
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (if (eq mode major-mode)
              (add-to-list 'buffer-mode-matches buf))))
      buffer-mode-matches))

  ;;;###autoload
  (defun esc/multi-occur-in-this-mode ()
    "Show all lines matching REGEXP in buffers with this major mode."
    (interactive)
    (multi-occur
     (esc/get-buffers-matching-mode major-mode)
     (car (occur-read-primary-args))))

  ;;;###autoload
  (defun esc/toggle-selective-display (column)
    "Enable code folding in current buffer."
    (interactive "P")
    (set-selective-display (if selective-display nil (or column 1))))

  ;;;###autoload
  (defun esc/toggle-fullscreen ()
    "Toggles whether the currently selected frame consumes the entire display
     or is decorated with a window border"
    (interactive)
    (let ((f (selected-frame)))
      (modify-frame-parameters f
                               `((fullscreen . ,(if (eq nil (frame-parameter f 'fullscreen))
                                                    'fullboth nil))))))

  ;;;###autoload
  (defun esc/unroll-cc-arguments ()
    "Unroll a function's arguments into a more readable
    one-per-line format. Be sure to invoke this defun from before the
    opening paren of the function's arguments.

    This function has delimeters based on cc-mode dialects, and as a
    result would not be very useful for a language like Lisp."
    (interactive)
    (let ((limit (save-excursion
                   (search-forward "(")
                   (backward-char)
                   (forward-sexp)
                   (point))))
      (save-excursion
        (while (and (< (point) limit)
                    (re-search-forward "[,\"]" limit t))
          (cond ((char-equal ?, (char-before))
                 (newline-and-indent))
                ((char-equal ?\" (char-before))
                 (re-search-forward "\""))))))
    (message "done"))


  ;;;###autoload
  (defun esc/swap-buffer-locations ()
    "Rotate your windows around and around."
    (interactive)
    (if (not (> (count-windows) 1))
        (error "You can't rotate a single window"))
    (let ((i 1))
      (let ((numWindows (count-windows)))
        (while  (< i numWindows)
          (let* ((w1 (elt (window-list) i))
                 (w2 (elt (window-list) (+ (% i numWindows) 1)))
                 (b1 (window-buffer w1))
                 (b2 (window-buffer w2))
                 (s1 (window-start w1))
                 (s2 (window-start w2)))
            (set-window-buffer w1  b2)
            (set-window-buffer w2 b1)
            (set-window-start w1 s2)
            (set-window-start w2 s1)
            (setq i (1+ i)))))))

  ;; generate programatically
  ;;;###autoload
  (defun esc/open-line-below ()
    "Create a new line above the current line. Can be used with point
     anywhere on the line."
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  ;;;###autoload
  (defun esc/open-line-above ()
    "Create a new line below the current line. Can be used with point
     anywhere on the line."
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  ;;;###autoload
  (defun esc/goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input."
    (interactive)
    (unwind-protect (progn
                      (linum-mode 1)
                      (goto-line (read-number "Goto line: ")))
      (linum-mode -1)))

  ;;;###autoload
  (defun esc/minimap-toggle ()
    "Toggle minimap for current buffer."
    (interactive)
    (when (require 'minimap nil 'noerror)
      (if (not (boundp 'minimap-bufname))
          (setf minimap-bufname nil))
      (if (null minimap-bufname)
          (minimap-create)
        (minimap-kill))))

  ;;;###autoload
  (defun esc/delete-whole-word ()
    "This defun will delete the entire word at point. This function
  relies on `esc/kill-whole-word'."
    (interactive)
    (esc/kill-whole-word t))

  ;; TODO: accept a prefix arg
  ;;;###autoload
  (defun esc/kill-whole-word (&optional delete)
    "This defun will kill the entire word at point (on both sides
  of point). DELETE, if non-nil, will prevent the word from being
  appended to the kill-ring."
    (interactive)
    (let ((bounds (bounds-of-thing-at-point 'word)))
      (save-excursion
        (goto-char (car bounds))
        (if (not delete)
            (kill-word 1)
          (delete-region (car bounds) (cdr bounds))))))

  ;;;###autoload
  (defun esc/eval-and-replace (&optional arg)
    "Replace the preceding sexp with its value."
    (interactive "P")
    (backward-kill-sexp)
    (let ((expression (current-kill 0)))
      (condition-case nil
          (progn
            (when arg (insert (concat expression " = ")))
            (prin1 (eval (read expression))
                   (current-buffer)))
        (error (message "Invalid expression")
               (insert expression)))))

  ;;;###autoload
  (defun esc/save-buffers-kill-emacs (&optional arg)
    "Offer to save each buffer(once only), then kill this Emacs process.
     With prefix ARG, silently save all file-visiting buffers, then kill."
    (interactive "P")
    (save-some-buffers arg t)
    (and (or (not (fboundp 'process-list))
             (let ((processes (process-list)) ;process-list is not defined on DOS
                   active)
               (while processes
                 (and (memq (process-status (car processes))
                            '(run stop open listen))
                      (process-query-on-exit-flag (car processes))
                      (setq active t))
                 (setq processes (cdr processes)))
               (or (not active)
                   (progn (list-processes t)
                          (yes-or-no-p
                           "Active processes exist; kill them and exit anyway? ")))))
         ;; Query the user for other things, perhaps.
         (run-hook-with-args-until-failure 'kill-emacs-query-functions)
         (or (null confirm-kill-emacs)
             (funcall confirm-kill-emacs "Really exit Emacs? "))
         (kill-emacs)))

  ;;;###autoload
  (defun esc/unkillable-scratch-buffer ()
    "Prevent the *scratch* buffer from ever being killed."
    (if (equal (buffer-name (current-buffer)) "*scratch*")
        (progn
          (delete-region (point-min) (point-max))
          (insert initial-scratch-message)
          nil)
      t))

  ;;;###autoload
  (defun esc/mode-line-other-buffer-other-window ()
    "Switch to `other-window', use `mode-line-other-buffer', and
      switch back to the original window."
    (interactive)
    (other-window 1)
    (mode-line-other-buffer)
    (other-window -1))

    ;;;###autoload
    (defun delete-word (arg)
      "Delete characters forward until encountering the end of a word.
    With argument, do this that many times."
      (interactive "p")
      (delete-region (point) (progn (forward-word arg) (point))))

    ;;;###autoload
    (defun backward-delete-word (arg)
      "Delete characters backward until encountering the end of a word.
    With argument, do this that many times."
      (interactive "p")
      (delete-word (- arg)))

  (provide 'emacs+)
#+END_SRC

* Help+
#+BEGIN_SRC emacs-lisp :tangle help+.el
  ;; TODO make this insert parens, and the appropriate spaces for
  ;; arguments. I'm envisioning a clean, cdlatex-mode type thing
  ;;;###autoload
  (defun esc/insert-defun-at-point (&optional key insert untranslated string)
    "Insert at point the name of the function KEY invokes.  KEY is a string.
    If INSERT (the prefix arg) is non-nil, insert the message in the
    buffer.  If non-nil, UNTRANSLATED is a vector of the untranslated
    events.  It can also be a number in which case the untranslated
    events from the last key hit are used.

    If KEY is a menu item or a tool-bar button that is disabled, this command
    temporarily enables it to allow getting help on disabled items and buttons."
    (interactive
     (let ((enable-disabled-menus-and-buttons t)
           (cursor-in-echo-area t)
           saved-yank-menu)
       (unwind-protect
           (let (key)
             ;; If yank-menu is empty, populate it temporarily, so that
             ;; "Select and Paste" menu can generate a complete event.
             (when (null (cdr yank-menu))
               (setq saved-yank-menu (copy-sequence yank-menu))
               (menu-bar-update-yank-menu "(any string)" nil))
             (setq key (read-key-sequence "Describe key (or click or menu item): "))
             ;; Clear the echo area message (Bug#7014).
             (message nil)
             ;; If KEY is a down-event, read and discard the
             ;; corresponding up-event.  Note that there are also
             ;; down-events on scroll bars and mode lines: the actual
             ;; event then is in the second element of the vector.
             (and (vectorp key)
                  (let ((last-idx (1- (length key))))
                    (and (eventp (aref key last-idx))
                         (memq 'down (event-modifiers (aref key last-idx)))))
                  (read-event))
             (list
              key
              (if current-prefix-arg (prefix-numeric-value current-prefix-arg))
              1))
         ;; Put yank-menu back as it was, if we changed it.
         (when saved-yank-menu
           (setq yank-menu (copy-sequence saved-yank-menu))
           (fset 'yank-menu (cons 'keymap yank-menu))))))

    (if (numberp untranslated)
        (setq untranslated (this-single-command-raw-keys)))
    (let* ((event (if (and (symbolp (aref key 0))
                           (> (length key) 1)
                           (consp (aref key 1)))
                      (aref key 1)
                    (aref key 0)))
           (modifiers (event-modifiers event))
           (standard-output (if insert (current-buffer) standard-output))
           (mouse-msg (if (or (memq 'click modifiers) (memq 'down modifiers)
                              (memq 'drag modifiers)) " at that spot" ""))
           (defn (key-binding key t))
           key-desc)
      ;; Handle the case where we faked an entry in "Select and Paste" menu.
      (if (and (eq defn nil)
               (stringp (aref key (1- (length key))))
               (eq (key-binding (substring key 0 -1)) 'yank-menu))
          (setq defn 'menu-bar-select-yank))
      ;; Don't bother user with strings from (e.g.) the select-paste menu.
      (if (stringp (aref key (1- (length key))))
          (aset key (1- (length key)) "(any string)"))
      (if (and (> (length untranslated) 0)
               (stringp (aref untranslated (1- (length untranslated)))))
          (aset untranslated (1- (length untranslated)) "(any string)"))
      ;; Now describe the key, perhaps as changed.
      (setq key-desc (help-key-description key untranslated))
      (if (or (null defn) (integerp defn) (equal defn 'undefined))
          (princ (format "%s%s is undefined" key-desc mouse-msg))
        (if string
            defn
          (insert (format "%S" defn))))))

  (provide 'help+)
#+END_SRC

Thanks to [[https://github.com/ubolonton/.emacs.d/blob/master/lib/single-file-modes/help-fns%252B.el%0A][help-fns+]].
#+BEGIN_SRC emacs-lisp :tangle help+.el
  ;;;###autoload
  (defun describe-keymap (keymap)
    "Describe bindings in KEYMAP, a variable whose value is a keymap.
  Completion is available for the keymap name."
    (interactive
     (list (intern
            (completing-read
             "Keymap: " obarray
             (lambda (m) (and (boundp m) (keymapp (symbol-value m))))
             t nil 'variable-name-history))))
    (unless (and (symbolp keymap) (boundp keymap) (keymapp (symbol-value keymap)))
      (error "`%S' is not a keymapp" keymap))
    (let ((name  (symbol-name keymap))
          (doc   (documentation-property keymap 'variable-documentation)))
      (help-setup-xref (list #'describe-keymap keymap) (interactive-p))
      (with-output-to-temp-buffer "*Help*"
        (princ name) (terpri)
        (princ (make-string (length name) ?-)) (terpri) (terpri)
        (when doc (princ doc) (terpri) (terpri))
        ;; Use `insert' instead of `princ', so control chars (e.g. \377) insert correctly.
        (with-current-buffer "*Help*"
          (insert (substitute-command-keys (concat "\\{" name "}")))))))

#+END_SRC

* extending core functionality

#+NAME: rename-deun
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun rename-defun (function)
    "Rename loaded FUNCTION to a new name. Makfunbound FUNCTION after
  evaling the newly named defun."
    (interactive (find-function-read))
    (if (null function)
        (message "You didn't specify a function")
      (let ((function-name (symbol-name function)))
        (find-function-do-it function nil 'switch-to-buffer)
        (let ((begin (point))
              (end (save-excursion (end-of-defun) (point)))
              (new-name (read-string (concat "Rename " function-name " to: "))))
          (save-excursion
            (replace-string function-name new-name t begin end))
          (eval-defun nil)
          (makfunbound function)))))
#+END_SRC

#+NAME: touch
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun touch ()
    "Updates mtime on the file described by the current buffer."
    (interactive)
    (shell-command (concat "touch " (shell-quote-argument (buffer-file-name))))
    (clear-visited-file-modtime)
    (message "File touched"))
#+END_SRC

#+NAME: insert key combination at point
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/insert-key-combination (key &optional arg)
    "Insert string describing KEY sequence. KEY is a string.
  If ARG is non nil, wrap the inserted string in some useful text
  depending on the value of ARG.

      Value of ARG      Example inserted string
      positive          \"C-h c\"
      negative          (kbd \"C-h c\")"
    (interactive "kType a key combination: \np")
    (let ((str (key-description key)))
      (insert (cond ((< arg 0)        (concat "(kbd \"" str "\")"))
                    ((not (eq arg 1)) (concat "\"" str "\""))
                    (t                 str)))))
#+END_SRC

#+NAME: Searching for word at point up or down
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun esc/search-word-backward ()
    "Find the previous occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-backward "w_")
      (goto-char
       (if (re-search-backward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))

  (defun esc/search-word-forward ()
    "Find the next occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-forward "w_")
      (goto-char
       (if (re-search-forward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))
#+END_SRC

* [0/2] TODOs
** [0/1] logically separate commands
*** TODO re-incorporate them back into org
** [0/1] org
*** TODO C-. to bury until current-buffer isn't in org-agenda-files
or possibly cycle through your init files
