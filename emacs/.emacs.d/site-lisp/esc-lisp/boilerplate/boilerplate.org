#+todo: TODO(t) VERIFY(v) IN-PROGRESS(p) PRINT(r) | OPTIONAL(o) HIATUS(h) DONE(d) DISCARDED(c) HACKED(k)
#+startup: content
* Introduction
#+NAME: license
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; boilerplate library - a home for useful, logically disparate functions
  ;; Copyright (C) <year>  <name of author>

  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program. If not, see <http://www.gnu.org/licenses/>.

  ;; Boilerplate Library
  ;; This library is for the code so straightforward that it doesn't
  ;; belong in my .emacs. Only tried-and-tested programs make it into
  ;; this vault.
#+END_SRC
* Hooks
Here are custom hooks esc appends to common exposed hooks.
Captain Hook. Hooks are great. Everybody should expose more hooks.
** prog-mode-hook
#+NAME: prog-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/prog-mode-hook nil
      "esc's code to \\[prog-mode-hook]."
      :type 'hook
      :options '((auto-revert-mode t)
                 (smerge-mode t))
      :group 'boil)

  ;;;###autoload
  (defun esc/prog-mode-hook ()
   "esc's hook to \\[prog-mode-hook]."
    (auto-revert-mode t)
    (smerge-mode t))
#+END_SRC
** minibuffer hooks
#+NAME: minibuffer-setup-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/minibuffer-setup-hook nil
    "esc's hook to run upon entering the minibuffer."
    :type         'hook
    :options      '(autopair-mode -1)
    :group        'boil)

  ;;;###autoload
  (defun esc/minibuffer-setup-hook ()
    "esc's hook to run whilst entering the minibuffer's domain."
    (autopair-mode -1)
    (define-key minibuffer-local-map (kbd "<escape>") nil))

  (defcustom esc/minibuffer-exit-hook nil
    "esc's hook to run upon exiting the minibuffer."
    :type         'hook
    :options      '()
    :group        'boil)

  ;;;###autoload
  (defun esc/minibuffer-exit-hook ()
    "esc's hook to run whilst exiting the minibuffer's domain."
    nil)
#+END_SRC

** c-mode-common-hook
#+NAME: c-mode-common-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/c-insert-ifdef-ndebug-printf-string nil
    "Debugging string to insert in \\[esc/c-insert-ifdef-ndebug-printf]."
    :type '(string)
    :options '("printf(\"%s \\n\", __FUNCTION__);")
    :group 'boil)
  (setq esc/c-insert-ifdef-ndebug-printf-string "printf(\"%s \\n\", __FUNCTION__);")

  (defcustom esc/c-mode-common-hook nil
    "esc's code to \\[c-mode-common-hook]."
    :type 'hook
    :options '((setq ff-always-in-other-window t)
               (setq ff-always-try-to-create nil)
               ;(idle-highlight t)
               (autoload 'disaster "disaster")
               (local-set-key (kbd "C-c d") 'disaster)
               (local-set-key (kbd "C-c o") 'ff-find-other-file)
               (local-set-key (kbd "C-M-;") 'esc/yank-displaced-doxygen-comment)
               (local-set-key (kbd "C-c d") 'esc/c-insert-ifdef-ndebug-printf)
               (c-turn-on-eldoc-mode))
    :group 'boil)

  ;;;###autoload
  (defun esc/c-mode-common-hook ()
    "esc's code to \\[c-mode-common-hook]."
    ;(idle-highlight t)
    (autoload 'disaster "disaster")
    (local-set-key (kbd "C-c d") 'disaster)
    (local-set-key (kbd "C-c o") 'ff-find-other-file)
    (local-set-key (kbd "C-c d") 'esc/c-insert-ifdef-ndebug-printf)
    (local-set-key (kbd "C-M-;") 'esc/yank-displaced-doxygen-comment)
    (local-set-key (kbd "C-M-S-u") 'esc/unroll-cc-arguments)
    (c-turn-on-eldoc-mode)
    (setq ff-always-in-other-window t
          ff-always-try-to-create nil))
#+END_SRC
** c++-mode-common-hook
#+NAME: c++-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
    (defcustom esc/c++-mode-hook nil
      "esc's code to \\[c++-mode-hook]."
      :type 'hook
      :options '((setq comment-start "/*")
                 (setq comment-end "*/"))
      :group 'boil)

    ;;;###autoload
    (defun esc/c++-mode-hook ()
      "esc's code to \\[c++-mode-hook]."
      (setq comment-start "/*"
            comment-end "*/"))
#+END_SRC
** emacs-lisp-mode-hook
#+NAME: emacs-lisp-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/emacs-lisp-mode-hook nil
    "esc's code to \\[emacs-lisp-mode-hook]."
    :type         'hook
    :options      '((turn-on-eldoc-mode))
    :group        'boil)

  ;;;###autoload
  (defun esc/emacs-lisp-mode-hook ()
    "esc's code to \\[emacs-lisp-mode-hook]."
    (turn-on-eldoc-mode))
#+END_SRC
** fundamental-mode-hook
#+NAME: fundamental-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/fundamental-mode-hook nil
    "esc's code to \\[fundamental-mode-hook]."
    :type         'hook
    :options      '((autopair-mode -1)
                    (flyspell-mode 1))
    :group        'boil)

  ;;;###autoload
  (defun esc/fundamental-mode-hook ()
    "esc's code to \\[fundamental-mode-hook]."
    (autopair-mode -1)
    (flyspell-mode 1))
#+END_SRC
** eshell-mode-hook
TODO: defcustom
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun esc/eshell-mode-hook ()
    (define-key eshell-mode-map (kbd "C-x C-p") 'eshell-previous-matching-input-from-input)
    (define-key eshell-mode-map (kbd "C-x C-n") 'eshell-next-matching-input-from-input)
    (when (require 'em-smart nil 'noerror)
      (setq eshell-where-to-jump 'begin
            eshell-review-quick-commands nil
            eshell-smart-space-goes-to-end t)))
#+END_SRC
** enh-ruby-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
    (defcustom esc/enh-ruby-mode-hook nil
      "esc's code to \\[enh-ruby-mode-hook]."
      :type         'hook
      :options      '((idle-highlight t))
      :group        'boil)

    ;;;###autoload
    (defun esc/enh-ruby-mode-hook ()
      "esc's code to \\[enh-ruby-mode-hook]."
      ;(idle-highlight t)
      )
#+END_SRC
** erc-mode-hook
#+NAME: erc-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/erc-mode-hook nil
    "esc's code to \\[erc-mode-hook]."
    :type         'hook
    :options      '((autopair-mode -1))
    :group        'boil)

  ;;;###autoload
  (defun esc/erc-mode-hook ()
    "esc's code to \\[erc-mode-hook]."
    (autopair-mode -1))
#+END_SRC
** comint-mode-hook
#+NAME: comint-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/comint-mode-hook nil
    "esc's code to \\[comint-mode-hook]."
    :type         'hook
    :options      '((define-key comint-mode-map "M-p" 'comint-previous-input)
                    (define-key comint-mode-map "M-S-p" 'ace-window))
    :group        'boil)

  ;;;###autoload
  (defun esc/comint-mode-hook ()
    "esc's code to \\[comint-mode-hook]."
    ;; TODO: find the active keymap in comint-mode
    (bind-key "M" 'self-insert-command)
    ;;(define-key comint-mode-map "M-p" 'comint-previous-input)
    ;;(define-key comint-mode-map "M-S-p" 'ace-window)
    )
#+END_SRC
** iedit-mode-hook
TODO: defcustom
#+NAME: iedit-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/iedit-mode-hook ()
    "esc's hook to \\[iedit-mode-hook]."
    (define-key iedit-mode-keymap (kbd "<RET>") 'iedit-mode) ;exit
    ;; Don't go overriding my M-x chord, you hear
    (define-key iedit-mode-keymap (kbd "C-'") 'execute-extended-command))
#+END_SRC

** org-mode-hook
TODO: defcustom
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/org-mode-hook()
    (org-indent-mode)
    (imenu-add-to-menubar "Imenu")
    (local-set-key (kbd "C-M-n") 'outline-next-visible-heading)
    (local-set-key (kbd "C-M-p") 'outline-previous-visible-heading)
    (local-set-key (kbd "C-c C-a") 'org-todo))
#+END_SRC
** big-fringe-mode-hook
TODO: defcustom
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/big-fringe-mode-hook ()
    ;; TODO: copy from ecrosson-mobl
    )
#+END_SRC
* Licenses
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/insert-short-gpl ()
    "Insert the short version of the GNU GPL v3."
    (interactive)
    (insert
     "<one line to give the program's name and a brief idea of what it does.>
  Copyright (C) <year>  <name of author>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
  "))
#+END_SRC

* Buffer+
#+BEGIN_SRC emacs-lisp :tangle buffer+.el
  ;;; buffer+.el --- Buffer and window management functions

  ;;; Commentary:
  ;;

  ;;; Code:

  ;;;###autoload
  (defun esc/indent-buffer ()
    "Indent the entire buffer without adjusting point or mark."
    (interactive)
    (save-excursion (indent-region (point-min) (point-max))))

  ;;;###autoload
  (defun kill-matching-buffers-no-ask (regexp &optional internal-too)
    "Kill buffers whose name matches the specified REGEXP.
  The optional second argument indicates whether to kill internal buffers too."
    (interactive "sKill buffers matching this regular expression: \nP")
    (dolist (buffer (buffer-list))
      (let ((name (buffer-name buffer)))
        (when (and name (not (string-equal name ""))
                   (or internal-too (/= (aref name 0) ?\s))
                   (string-match regexp name))
          (kill-buffer buffer)))))

  ;;;###autoload
  (defmacro esc/toggle-fullscreen-buffer (win-register toggled-mode-test toggle-command
                                                       &optional
                                                       toggle-command-test
                                                       clear-command)
    "Bring up a temporary buffer in fullscreen mode, or restore the
  previous window configuration.

  WIN-REGISTER         is the register to store the old window configuration in.

  TOGGLED-MODE-TEST    is the major mode of the toggled state, in other words a
                       test to determine which way to toggle the buffers.

  TOGGLE-COMMAND       is the command to run when toggling into the temporary
                       state.

  CLEAR-COMMAND        is an optional command to run when reverting back to the
                       original state; i.e. toggle a flag"
    (declare (indent defun))
    `(progn
       (if ,toggled-mode-test
           (progn (jump-to-register ,win-register)
                  (when (not (equal nil ,clear-command))
                    ,clear-command))
         (window-configuration-to-register ,win-register)
         ,toggle-command
         (delete-other-windows))))

  ;;;###autoload
  (defmacro esc/save-window-configuration (win-register &rest body)
    "Save current window configuration to WIN-REGISTER, run BODY,
  and restory WIN-REGISTER."
    (declare (indent defun))
    `(progn
       (window-configuration-to-register ,win-register)
       (progn ,@body)
       (jump-to-register ,win-register)))

  ;;;###autoload
  (defun esc/should-have-opened-this-in-other-window (&optional COUNT)
    "Returns to the previous buffer in current window, calls
  `other-window', and opens the buffer in the new window.

  COUNT is the number of windows to advance; the argument is passed
  directly to `other-window', so see the documentation for more
  details."
    (interactive)
    (when (equal nil COUNT)
      (setq COUNT 1))
    (let ((target (buffer-name)))
      (switch-to-prev-buffer)
      (other-window COUNT)
      (switch-to-buffer target)))

  ;;;###autoload
  (defun buffers-matching-regexp (regexp &optional names)
    "Return a list of buffers matching REGEXP.

  If NAMES is non-nil, return a list of names (strings) instead of
  buffers."
    (remq nil
          (mapcar (lambda (buf)
                    (let ((name (buffer-name buf)))
                      (when (string-match regexp name)
                        (if names
                            (buffer-name buf)
                          buf))))
                  (buffer-list))))

  ;;;###autoload
  (defun esc/rotate-window-split ()
    "Transform a vertically split window to a horizontally split
  window."
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

  ;;;###autoload
  (defun esc/bury-buffer-delete-window ()
    "Kill current window and bury the current buffer to the bottom
  of the buffer list."
    (interactive)
    (bury-buffer)
    (delete-window))

  ;;;###autoload
  (defun esc/bury-other-buffer (&optional switch-to-other-buffer)
    "Bury the buffer that `mode-line-other-buffer' will take you
  to.

  If SWITCH-TO-OTHER-BUFFER is non-nil (e.g. this command is
  prefixed) then after the other-buffer is buried, the command
  `mode-line-other-buffer' will be used to switch buffers."
    (interactive "p")
    (mode-line-other-buffer)
    (bury-buffer)
    (when current-prefix-arg (mode-line-other-buffer)))

  ;;;###autoload
  (defun esc/raise-eshell ()
    "Bring up a full-screen eshell or restore previous window
  configuration."
    (interactive)
    (esc/toggle-fullscreen-buffer :eshell-fullscreen
      (string= "eshell-mode" major-mode)
      (eshell)))

  ;;;###autoload
  (defun esc/raise-eshell-in-current-dir ()
    "Bring up a full-screen eshell in the current directory or
  restore previous window configuration."
    (interactive)
    (esc/toggle-fullscreen-buffer
      :eshell-fullscreen
      (string= "eshell-mode" major-mode)
      (when (buffer-file-name)
        (let ((dir (file-name-directory (buffer-file-name))))
          (eshell)
          (insert "cd " dir)
          (with-no-warnings (eshell-send-input))))))

  ;;;###autoload
  (defun esc/raise-magit-status ()
    "Bring up a full-screen magit-status or restore previous
  window configuration.

  This defun will not raise magit if you have merge conflicts in
  the current buffer.

  This defun kills all buffers matching regexp '^*magit: ' upon the
  exit toggle of the fullscreen magit buffer"
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (when (re-search-forward "^<<<<<<< variant" nil 'noerror)
        (error "Resolve merge conflicts first.")))
    (esc/toggle-fullscreen-buffer
      :magit-fullscreen
      (string= "magit-status-mode" major-mode)
      (progn (if (not (buffer-file-name))
                 (message "Buffer not associated with a file")
               (save-buffer)
               (magit-status (file-name-directory (buffer-file-name)))))
      nil (kill-matching-buffers-no-ask "^*magit: ")))

  ;; Thanks sacha! See
  ;; [[http://pages.sachachua.com/.emacs.d/Sacha.html#sec-1-5-1][Sacha
  ;; Chua's Emacs configuration]] for more tips.
  ;;;###autoload
  (defun esc/vsplit-last-buffer (prefix)
    "Split the window vertically and display the previous buffer.
  Argument PREFIX when nil switches the new buffer to the last buffer."
    (interactive "p")
    (split-window-vertically)
    (other-window 1 nil)
    (unless prefix (switch-to-next-buffer)))

  ;;;###autoload
  (defun esc/hsplit-last-buffer (prefix)
    "Split the window horizontally and display the previous buffer.
  Argument PREFIX when nil switches the new buffer to the last buffer."
    (interactive "p")
    (split-window-horizontally)
    (other-window 1 nil)
    (unless prefix (switch-to-next-buffer)))

  (provide 'buffer+)

  ;;; buffer+.el ends here
#+END_SRC
* Compilation+
#+BEGIN_SRC emacs-lisp :tangle compilation+.el
  ;;; compilation+.el --- Compilation-related functions

  ;;; Commentary:
  ;;

  ;;; Code:

  ;;;###autoload
  (defun esc/auto-byte-recompile ()
    "If the current buffer is in emacs-lisp-mode and there already exists an .elc
  file corresponding to the current buffer file, then recompile the file."
    (interactive)
    (when (require 'bytecomp nil 'noerror)
      (when (and (eq major-mode 'emacs-lisp-mode)
                 (file-exists-p (byte-compile-dest-file buffer-file-name)))
        (byte-compile-file buffer-file-name))))

  ;;;###autoload
  (defun byte-compile-directory(dir)
    "Compile an .elc file for every .el file contained under
    DIR (recursive)."
    (byte-recompile-directory (expand-file-name dir) 0))

  (provide 'compilation+)

  ;;; compilation+.el ends here
#+END_SRC
* Org+
#+BEGIN_SRC emacs-lisp :tangle org+.el
  ;; todo: use current line in absence of region
  (defmacro esc/define-org-header-indentation(funcname callback)
    "Define functions to manipulate the header level of selected
  region in `org-mode'."
    (let ((command-name (intern (format "esc/org-%s-headers-in-region" funcname)))
          (docstring (format "%s `org-mode' headers arg times in currently
  selected region."
                             funcname)))
    `(defun ,command-name (&optional arg)
       ,docstring
       (interactive "p")
       (save-excursion
         (let ((beg (save-excursion
                      (goto-char (region-beginning)) (beginning-of-line) (point)))
               (end (save-excursion
                      (goto-char (region-end)) (end-of-line) (point))))
           (goto-char end)
           (while (and (< beg (point))
                       (re-search-backward "^\*" beg 'noerror))
             (dotimes (i arg) ,callback)
             (previous-line)
             (end-of-line)))))))

  (mapcar (lambda (data)
            (let ((funcname (car data))
                  (callback (cadr data)))
              (eval `(esc/define-org-header-indentation ,funcname ,callback))))
          '((indent (insert "*"))
            (unindent (kill-forward-chars 1))))

  (provide 'org+)

  ;;; org+.el ends here
#+END_SRC
* Displaced yank
#+BEGIN_SRC emacs-lisp :tangle displaced-yank.el
  ;;; displaced-yank.el --- Yank and move point
  ;; Copyright (C) 2015  esc

  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program. If not, see <http://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;;; Code:

  (defmacro esc/define-displaced-yank (funcname data)
    "Create a defun of name FUNCNAME that yanks and moves according
    to DATA. DATA is of the form (STR, MOVE). STR is the string to
    yank and MOVE is the number of chars to move backward.

    Note that negative values of MOVE are valid."
    (let ((funsymbol (intern (format "esc/yank-displaced-%s" funcname)))
          (docstring (format "(insert \"%s\") and (backward-char %d). This command can be prefixed, and will iterate N times." (car data) (or (cadr data) 1)))
          (char (car data))
          (back (or (cadr data) 1)))
      `(defun ,funsymbol (&optional N)
         ,docstring
         (interactive "p")
         (dotimes (i (or N 1))
           (insert ,char)
           (backward-char ,back)))))

  (mapcar (lambda (function)
            (let ((funcname (car function))
                  (data     (cdr function)))
              (eval `(esc/define-displaced-yank ,funcname ,data))))
          '((parens              "()")
            (braces              "{}")
            (brackets            "[]")
            (brackets-with-colon "[:]")
            (pipes               "||")
            (chevrons            "<>")
            (quotes              "\"\"")
            (single-quotes       "''")
            (stars               "**")
            (dollars             "$$")
            (equals              "==")
            ;; a good example of code reuse
            (ticks               "`'")
            (little-arrow        "->" 0)
            (doxygen-comment     "/*!  */" 3))) ;; todo: implement with yasnippet

  (provide 'displaced-yank)

  ;;; displaced-yank.el ends here
#+END_SRC
* Emacs+
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;; TOOD: accept a prefix to yank `buffer-file-name'
  ;;;###autoload
  (defun esc/minibuffer-display-buffer-file-name ()
    "Display `buffer-file-name' in the minibuffer."
    (interactive)
    (ignore-errors
      (message (format "%s" (buffer-file-name)))))
#+END_SRC

I'm feelin' a little [[http://stackoverflow.com/a/18680600][Haskelly]]
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun combinations (&rest lists)
    "Return a list of all possible combinations of the elements of
  LISTS. Think applicative functors from Haskell."
    (if (car lists)
        (mapcan (lambda (inner-val)
                  (mapcar (lambda (outer-val)
                            (cons outer-val
                                  inner-val))
                          (car lists)))
                (apply #'combinations (cdr lists)))
      (list nil)))
#+END_SRC

[[http://whattheemacsd.com/key-bindings.el-03.html][Magnar]] said it best, here's one command I could not live without.
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun esc/pull-up-line (&optional arg)
    "Pull up ARG lines."
    (interactive "p")
    (dotimes (i arg)
      (join-line -1)))
#+END_SRC

Thanks to the prolific [[http://ergoemacs.org/emacs/modernization_upcase-word.html][Xah Lee]].
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun esc/toggle-letter-case ()
    "Toggle the letter case of current word or text selection.
    Toggles between: “all lower”, “Init Caps”, “ALL CAPS”."
    (interactive)
    (let (p1 p2 (deactivate-mark nil) (case-fold-search nil))
      (if (region-active-p)
          (setq p1 (region-beginning) p2 (region-end))
        (let ((bds (bounds-of-thing-at-point 'word) ) )
          (setq p1 (car bds) p2 (cdr bds)) ) )
      (when (not (eq last-command this-command))
        (save-excursion
          (goto-char p1)
          (cond
           ((looking-at "[[:lower:]][[:lower:]]")
            (put this-command 'state "all lower"))
           ((looking-at "[[:upper:]][[:upper:]]")
            (put this-command 'state "all caps"))
           ((looking-at "[[:upper:]][[:lower:]]")
            (put this-command 'state "init caps"))
           ((looking-at "[[:lower:]]")
            (put this-command 'state "all lower"))
           ((looking-at "[[:upper:]]")
            (put this-command 'state "all caps"))
           (t (put this-command 'state "all lower")))))
      (cond
       ((string= "all lower" (get this-command 'state))
        (upcase-initials-region p1 p2)
        (put this-command 'state "init caps"))
       ((string= "init caps" (get this-command 'state))
        (upcase-region p1 p2)
        (put this-command 'state "all caps"))
       ((string= "all caps" (get this-command 'state))
        (downcase-region p1 p2)
        (put this-command 'state "all lower")))))
#+END_SRC

[[http://www.emacswiki.org/emacs/TrampMode#toc30][EmacsWiki: Tramp Mode]]
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun sudo-edit-current-file ()
    "Edit the current file as sudo with tramp, without needing to
  navigate to it or losing your place in the file. Works on local
  or remote files."
    (interactive)
    (let ((position (point)))
      (find-alternate-file
       (if (file-remote-p (buffer-file-name))
           (let ((vec (tramp-dissect-file-name (buffer-file-name))))
             (tramp-make-tramp-file-name
              "sudo"
              (tramp-file-name-user vec)
              (tramp-file-name-host vec)
              (tramp-file-name-localname vec)))
         (concat "/sudo:root@localhost:" (buffer-file-name))))
      (goto-char position)))
#+END_SRC

[[http://emacsredux.com/blog/2015/01/18/clear-comint-buffers/][Clear Comint Buffers - Emacs Redux]]
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  (defun comint-clear-buffer ()
    (interactive)
    (let ((comint-buffer-maximum-size 0))
      (comint-truncate-buffer)))
#+END_SRC

Many thanks to [[http://www.emacswiki.org/emacs/DictMode][EmacsWiki]].
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun esc/dictionary-search ()
    (interactive)
    (require 'dictionary)
    (let ((word (current-word))
          (enable-recursive-minibuffers t)
          (val))
      (setq val (read-from-minibuffer
                 (concat "Word"
                         (when word
                           (concat " (" word ")"))
                         ": ")))
      (dictionary-new-search
       (cons (cond
              ((and (equal val "") word)
               word)
              ((> (length val) 0)
               val)
              (t
               (error "No word to lookup")))
             dictionary-default-dictionary))))
#+END_SRC

Courtesy of [[http://oremacs.com/2015/01/26/occur-dwim/][or emacs]].
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun occur-dwim ()
    "Call `occur' with a sane default.

  \\[occur-dwim] will offer as the default candidate:

  - the current region, if it's active
  - the current symbol, otherwise"
    (interactive)
    (push (if (region-active-p)
              (buffer-substring-no-properties
               (region-beginning)
               (region-end))
            (thing-at-point 'symbol))
          regexp-history)
    (call-interactively 'occur))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun esc/insert-numeric-sequence ()
    "Insert a sequence of numbers at point, separated by spaces. Inclusive."
    (interactive)
    (let ((begin (read-number "Begin: "))
          (end (read-number "End: ")))
      (dotimes (i (- (+ 1 end) begin))
        (insert (number-to-string (+ i begin)))
        (insert " "))))

  ;;;###autoload
  (defun esc/copy-line (&optional arg)
    "Copy current line in the kill ring."
    (interactive "p")
    (dotimes (i arg)
      (kill-ring-save (line-beginning-position)
                      (line-beginning-position 2)))
    (message "Line copied."))

  ;;;###autoload
  (defun esc/remove-dos-eol ()
    "Do not show ^M in files containing mixed UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))

  ;;;###autoload
  (defun esc/word-count (&optional begin end)
    "Count words bounded by mark and cursor; if no region defined, use buffer."
    (interactive "r")
    (let ((b (if mark-active begin (point-min)))
          (e (if mark-active end (point-max))))
      (message "Word count: %s" (how-many "\\w+" b e))))

  ;;;###autoload
  (defun esc/time ()
    "Insert string for the current esc/time formatted as '2:34 PM'."
    (interactive)
    (insert (format-time-string "%I:%M %p")))

  ;;;###autoload
  (defun esc/date ()
    "Insert string for today's esc/date nicely formatted in American style,
     e.g. Sunday September 17, 2000."
    (interactive)
    (let ((str "%A %B %e, %Y"))
      (if (called-interactively-p 'any)
          (insert (format-time-string str))
        (message (format-time-string str)))))

  ;;;###autoload
  (defun esc/insert-date (prefix)
    "Insert the current date. With prefix-argument, use ISO format. With
     two prefix arguments, write out the day and month name."
    (interactive "P")
    (let ((format (cond
                   ((not prefix) "%d.%m.%Y")
                   ((equal prefix '(4)) "%Y-%m-%d")
                   ((equal prefix '(16)) "%A, %d. %B %Y")))
          (system-time-locale "de_DE"))
      (insert (format-time-string format))))

  ;;;###autoload
  (defun esc/back-to-indentation-or-beginning ()
    "Returns the point to the beginning of the current line, or if
  already there, the beginning of text on the current line."
    (interactive)
    (let ((pt (point)))
      (beginning-of-line)
      (when (eq pt (point))
        (beginning-of-line-text))))

  ;;;###autoload
  (defun esc/increment-number-at-point (arg)
    "Increment the number at point. Can be prefaced with a multiplier."
    (interactive "p")
    (dotimes (i arg)
      (skip-chars-backward "0123456789")
      (or (looking-at "[[:digit:]]+")
          (error "No number at point"))
      (replace-match (number-to-string
                      (1+ (string-to-number (match-string 0)))))))

  ;;;###autoload
  (defun esc/delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))

  ;;;###autoload
  (defun esc/rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name new-name))))))

  ;;;###autoload
  (defun esc/get-buffers-matching-mode (mode)
    "Returns a list of buffers where their major-mode is equal to MODE."
    (let ((buffer-mode-matches '()))
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (if (eq mode major-mode)
              (add-to-list 'buffer-mode-matches buf))))
      buffer-mode-matches))

  ;;;###autoload
  (defun esc/multi-occur-in-this-mode ()
    "Show all lines matching REGEXP in buffers with this major mode."
    (interactive)
    (multi-occur
     (esc/get-buffers-matching-mode major-mode)
     (car (occur-read-primary-args))))

  ;;;###autoload
  (defun esc/toggle-selective-display (column)
    "Enable code folding in current buffer."
    (interactive "P")
    (set-selective-display (if selective-display nil (or column 1))))

  ;;;###autoload
  (defun esc/unroll-cc-arguments ()
    "Unroll a function's arguments into a more readable
    one-per-line format. Be sure to invoke this defun from before the
    opening paren of the function's arguments.

    This function has delimeters based on cc-mode dialects, and as a
    result would not be very useful for a language like Lisp."
    (interactive)
    (let ((limit (save-excursion
                   (search-forward "(")
                   (backward-char)
                   (forward-sexp)
                   (point))))
      (save-excursion
        (while (and (< (point) limit)
                    (re-search-forward "[,\"]" limit t))
          (cond ((char-equal ?, (char-before))
                 (newline-and-indent))
                ((char-equal ?\" (char-before))
                 (re-search-forward "\""))))))
    (message "done"))


  ;;;###autoload
  (defun esc/swap-buffer-locations ()
    "Rotate your windows around and around."
    (interactive)
    (if (not (> (count-windows) 1))
        (error "You can't rotate a single window"))
    (let ((i 1))
      (let ((numWindows (count-windows)))
        (while  (< i numWindows)
          (let* ((w1 (elt (window-list) i))
                 (w2 (elt (window-list) (+ (% i numWindows) 1)))
                 (b1 (window-buffer w1))
                 (b2 (window-buffer w2))
                 (s1 (window-start w1))
                 (s2 (window-start w2)))
            (set-window-buffer w1  b2)
            (set-window-buffer w2 b1)
            (set-window-start w1 s2)
            (set-window-start w2 s1)
            (setq i (1+ i)))))))

  ;; generate programatically
  ;;;###autoload
  (defun esc/open-line-below ()
    "Create a new line above the current line. Can be used with point
     anywhere on the line."
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  ;;;###autoload
  (defun esc/open-line-above ()
    "Create a new line below the current line. Can be used with point
     anywhere on the line."
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  ;;;###autoload
  (defun esc/goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input."
    (interactive)
    (unwind-protect (progn
                      (linum-mode 1)
                      (goto-line (read-number "Goto line: ")))
      (linum-mode -1)))

  ;;;###autoload
  (defun esc/delete-whole-word ()
    "This defun will delete the entire word at point. This function
  relies on `esc/kill-whole-word'."
    (interactive)
    (esc/kill-whole-word t))

  ;; TODO: accept a prefix arg
  ;;;###autoload
  (defun esc/kill-whole-word (&optional delete)
    "This defun will kill the entire word at point (on both sides
  of point). DELETE, if non-nil, will prevent the word from being
  appended to the kill-ring."
    (interactive)
    (let ((bounds (bounds-of-thing-at-point 'word)))
      (save-excursion
        (goto-char (car bounds))
        (if (not delete)
            (kill-word 1)
          (delete-region (car bounds) (cdr bounds))))))

  ;;;###autoload
  (defun esc/eval-and-replace (&optional arg)
    "Replace the preceding sexp with its value."
    (interactive "P")
    (backward-kill-sexp)
    (let ((expression (current-kill 0)))
      (condition-case nil
          (progn
            (when arg (insert (concat expression " = ")))
            (prin1 (eval (read expression))
                   (current-buffer)))
        (error (message "Invalid expression")
               (insert expression)))))

  ;;;###autoload
  (defun esc/save-buffers-kill-emacs (&optional arg)
    "Offer to save each buffer(once only), then kill this Emacs process.
     With prefix ARG, silently save all file-visiting buffers, then kill."
    (interactive "P")
    (save-some-buffers arg t)
    (and (or (not (fboundp 'process-list))
             (let ((processes (process-list)) ;process-list is not defined on DOS
                   active)
               (while processes
                 (and (memq (process-status (car processes))
                            '(run stop open listen))
                      (process-query-on-exit-flag (car processes))
                      (setq active t))
                 (setq processes (cdr processes)))
               (or (not active)
                   (progn (list-processes t)
                          (yes-or-no-p
                           "Active processes exist; kill them and exit anyway? ")))))
         ;; Query the user for other things, perhaps.
         (run-hook-with-args-until-failure 'kill-emacs-query-functions)
         (or (null confirm-kill-emacs)
             (funcall confirm-kill-emacs "Really exit Emacs? "))
         (kill-emacs)))

  ;;;###autoload
  (defun esc/unkillable-scratch-buffer ()
    "Prevent the *scratch* buffer from ever being killed."
    (if (not (equal (buffer-name (current-buffer)) "*scratch*"))
        t
      (delete-region (point-min) (point-max))
      (insert (or initial-scratch-message ""))
      nil))

  ;;;###autoload
  (defun esc/mode-line-other-buffer-other-window ()
    "Switch to `other-window', use `mode-line-other-buffer', and
      switch back to the original window."
    (interactive)
    (other-window 1)
    (mode-line-other-buffer)
    (other-window -1))

    ;;;###autoload
    (defun delete-word (arg)
      "Delete characters forward until encountering the end of a word.
    With argument, do this that many times."
      (interactive "p")
      (delete-region (point) (progn (forward-word arg) (point))))

    ;;;###autoload
    (defun backward-delete-word (arg)
      "Delete characters backward until encountering the end of a word.
    With argument, do this that many times."
      (interactive "p")
      (delete-word (- arg)))

  ;; TODO: find a way to keep these window changes from being registered
  ;; by winner-mode
  ;;;###autoload
  (defun esc/follow-mode-80-char-compliant ()
    "Open the current buffer in `follow-mode' in as many 80-char
  windows as you can fit on this screen."
    (interactive)
    (delete-other-windows)
    (follow-mode 1)
    (let ((width (window-total-width nil 'floor)))
      (while (> width 80)
        (split-window-horizontally)
        (balance-windows)
        (setq width (window-total-width nil 'floor))))
    (delete-window)
    (balance-windows)
    (recenter-top-bottom))

  ;;;###autoload
  (defun esc/hsplit-last-buffer-follow-mode ()
    "Split the current buffer horizontally and engage function
  `follow-mode'."
    (interactive)
    (esc/hsplit-last-buffer t)
    (follow-mode 1))

  (provide 'emacs+)
#+END_SRC

* OS interaction
#+BEGIN_SRC emacs-lisp :tangle os-interaction.el
  ;;; os-interaction.el --- Emacs should play nicely with whatever OS it's hiding

  ;;; Commentary:
  ;;

  ;;; Code:

  ;;;###autoload
  (defun esc/middle-click-yank ()
    "Yank from the middle click mouse buffer."
    (interactive)
    (mouse-yank-primary 1))

  ;;;###autoload
  (defun esc/insert-file-name (&optional ARG)
    "Inserts the name of the current file (including extension) at point.

  When ARG is non-nil, the filename will be printed in a different format.
  If ARG is 0, insert the full path of the filename.
  If ARG is - (or -1), insert the filename without extension."
    (interactive "p")
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (let ((output (cond ((eq ARG 0)   filename)
                            ((eq ARG -1)  (file-name-nondirectory
                                           (file-name-sans-extension filename)))
                            (t (file-name-nondirectory filename)))))
          (insert output)))))

  ;;;###autoload
  (defun esc/copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

  (provide 'os-interaction)

  ;;; os-interaction.el ends here
#+END_SRC
* Help+
#+BEGIN_SRC emacs-lisp :tangle help+.el
  ;; TODO make this insert parens, and the appropriate spaces for
  ;; arguments. I'm envisioning a clean, cdlatex-mode type thing
  ;;;###autoload
  (defun esc/insert-defun-at-point (&optional key insert untranslated string)
    "Insert at point the name of the function KEY invokes.  KEY is a string.
    If INSERT (the prefix arg) is non-nil, insert the message in the
    buffer.  If non-nil, UNTRANSLATED is a vector of the untranslated
    events.  It can also be a number in which case the untranslated
    events from the last key hit are used.

    If KEY is a menu item or a tool-bar button that is disabled, this command
    temporarily enables it to allow getting help on disabled items and buttons."
    (interactive
     (let ((enable-disabled-menus-and-buttons t)
           (cursor-in-echo-area t)
           saved-yank-menu)
       (unwind-protect
           (let (key)
             ;; If yank-menu is empty, populate it temporarily, so that
             ;; "Select and Paste" menu can generate a complete event.
             (when (null (cdr yank-menu))
               (setq saved-yank-menu (copy-sequence yank-menu))
               (menu-bar-update-yank-menu "(any string)" nil))
             (setq key (read-key-sequence "Describe key (or click or menu item): "))
             ;; Clear the echo area message (Bug#7014).
             (message nil)
             ;; If KEY is a down-event, read and discard the
             ;; corresponding up-event.  Note that there are also
             ;; down-events on scroll bars and mode lines: the actual
             ;; event then is in the second element of the vector.
             (and (vectorp key)
                  (let ((last-idx (1- (length key))))
                    (and (eventp (aref key last-idx))
                         (memq 'down (event-modifiers (aref key last-idx)))))
                  (read-event))
             (list
              key
              (if current-prefix-arg (prefix-numeric-value current-prefix-arg))
              1))
         ;; Put yank-menu back as it was, if we changed it.
         (when saved-yank-menu
           (setq yank-menu (copy-sequence saved-yank-menu))
           (fset 'yank-menu (cons 'keymap yank-menu))))))

    (if (numberp untranslated)
        (setq untranslated (this-single-command-raw-keys)))
    (let* ((event (if (and (symbolp (aref key 0))
                           (> (length key) 1)
                           (consp (aref key 1)))
                      (aref key 1)
                    (aref key 0)))
           (modifiers (event-modifiers event))
           (standard-output (if insert (current-buffer) standard-output))
           (mouse-msg (if (or (memq 'click modifiers) (memq 'down modifiers)
                              (memq 'drag modifiers)) " at that spot" ""))
           (defn (key-binding key t))
           key-desc)
      ;; Handle the case where we faked an entry in "Select and Paste" menu.
      (if (and (eq defn nil)
               (stringp (aref key (1- (length key))))
               (eq (key-binding (substring key 0 -1)) 'yank-menu))
          (setq defn 'menu-bar-select-yank))
      ;; Don't bother user with strings from (e.g.) the select-paste menu.
      (if (stringp (aref key (1- (length key))))
          (aset key (1- (length key)) "(any string)"))
      (if (and (> (length untranslated) 0)
               (stringp (aref untranslated (1- (length untranslated)))))
          (aset untranslated (1- (length untranslated)) "(any string)"))
      ;; Now describe the key, perhaps as changed.
      (setq key-desc (help-key-description key untranslated))
      (if (or (null defn) (integerp defn) (equal defn 'undefined))
          (princ (format "%s%s is undefined" key-desc mouse-msg))
        (if string
            defn
          (insert (format "%S" defn))))))

  (provide 'help+)
#+END_SRC

Thanks to [[https://github.com/ubolonton/.emacs.d/blob/master/lib/single-file-modes/help-fns%252B.el%0A][help-fns+]].
#+BEGIN_SRC emacs-lisp :tangle help+.el
  ;;;###autoload
  (defun describe-keymap (keymap)
    "Describe bindings in KEYMAP, a variable whose value is a keymap.
  Completion is available for the keymap name."
    (interactive
     (list (intern
            (completing-read
             "Keymap: " obarray
             (lambda (m) (and (boundp m) (keymapp (symbol-value m))))
             t nil 'variable-name-history))))
    (unless (and (symbolp keymap) (boundp keymap) (keymapp (symbol-value keymap)))
      (error "`%S' is not a keymapp" keymap))
    (let ((name  (symbol-name keymap))
          (doc   (documentation-property keymap 'variable-documentation)))
      (help-setup-xref (list #'describe-keymap keymap) (interactive-p))
      (with-output-to-temp-buffer "*Help*"
        (princ name) (terpri)
        (princ (make-string (length name) ?-)) (terpri) (terpri)
        (when doc (princ doc) (terpri) (terpri))
        ;; Use `insert' instead of `princ', so control chars (e.g. \377) insert correctly.
        (with-current-buffer "*Help*"
          (insert (substitute-command-keys (concat "\\{" name "}")))))))

#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (provide 'boilerplate)
#+END_SRC

* extending core functionality

#+NAME: rename-deun
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun rename-defun (function)
    "Rename loaded FUNCTION to a new name. Makfunbound FUNCTION after
  evaling the newly named defun."
    (interactive (find-function-read))
    (if (null function)
        (message "You didn't specify a function")
      (let ((function-name (symbol-name function)))
        (find-function-do-it function nil 'switch-to-buffer)
        (let ((begin (point))
              (end (save-excursion (end-of-defun) (point)))
              (new-name (read-string (concat "Rename " function-name " to: "))))
          (save-excursion
            (replace-string function-name new-name t begin end))
          (eval-defun nil)
          (makfunbound function)))))
#+END_SRC

#+NAME: touch
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun touch ()
    "Updates mtime on the file described by the current buffer."
    (interactive)
    (shell-command (concat "touch " (shell-quote-argument (buffer-file-name))))
    (clear-visited-file-modtime)
    (message "File touched"))
#+END_SRC

#+NAME: insert key combination at point
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/insert-key-combination (key &optional arg)
    "Insert string describing KEY sequence. KEY is a string.
  If ARG is non nil, wrap the inserted string in some useful text
  depending on the value of ARG.

      Value of ARG      Example inserted string
      positive          \"C-h c\"
      negative          (kbd \"C-h c\")"
    (interactive "kType a key combination: \np")
    (let ((str (key-description key)))
      (insert (cond ((< arg 0)        (concat "(kbd \"" str "\")"))
                    ((not (eq arg 1)) (concat "\"" str "\""))
                    (t                 str)))))
#+END_SRC

#+NAME: Searching for word at point up or down
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun esc/search-word-backward ()
    "Find the previous occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-backward "w_")
      (goto-char
       (if (re-search-backward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))

  (defun esc/search-word-forward ()
    "Find the next occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-forward "w_")
      (goto-char
       (if (re-search-forward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))
#+END_SRC

* [0/2] TODOs
** [0/1] logically separate commands
*** TODO re-incorporate them back into org
** [0/1] org
*** TODO C-. to bury until current-buffer isn't in org-agenda-files
or possibly cycle through your init files
