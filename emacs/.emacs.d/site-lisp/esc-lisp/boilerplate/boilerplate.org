#+todo: TODO(t) VERIFY(v) IN-PROGRESS(p) PRINT(r) | OPTIONAL(o) HIATUS(h) DONE(d) DISCARDED(c) HACKED(k)
#+startup: content
* Introduction
#+NAME: license
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; boilerplate library - a home for useful, logically disparate functions
  ;; Copyright (C) <year>  <name of author>

  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program. If not, see <http://www.gnu.org/licenses/>.

  ;; Boilerplate Library
  ;; This library is for the code so straightforward that it doesn't
  ;; belong in my .emacs. Only tried-and-tested programs make it into
  ;; this vault.
#+END_SRC
* Hooks
Here are custom hooks esc appends to common exposed hooks.
Captain Hook. Hooks are great. Everybody should expose more hooks.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/multiple-cursors-mode-disabled-hook ())
#+END_SRC
** has no better home
#+BEGIN_SRC emacs-lisp
  ;;;###autoload
  (defun esc/auto-byte-recompile ()
    "If the current buffer is in emacs-lisp-mode and there already exists an .elc
  file corresponding to the current buffer file, then recompile the file."
    (interactive)
    (when (require 'bytecomp nil 'noerror)
      (when (and (eq major-mode 'emacs-lisp-mode)
                 (file-exists-p (byte-compile-dest-file buffer-file-name)))
        (byte-compile-file buffer-file-name))))
#+END_SRC

** prog-mode-hook
#+NAME: prog-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/prog-mode-hook nil
      "esc's code to \\[prog-mode-hook]."
      :type 'hook
      :options '((auto-revert-mode t)
                 (smerge-mode t))
      :group 'boil)

  ;;;###autoload
  (defun esc/prog-mode-hook ()
   "esc's hook to \\[prog-mode-hook]."
    (auto-revert-mode t)
    (smerge-mode t))
#+END_SRC
** minibuffer hooks
#+NAME: minibuffer-setup-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/minibuffer-setup-hook nil
    "esc's hook to run upon entering the minibuffer."
    :type         'hook
    :options      '(autopair-mode -1)
    :group        'boil)

  ;;;###autoload
  (defun esc/minibuffer-setup-hook ()
    "esc's hook to run whilst entering the minibuffer's domain."
    (autopair-mode -1)
    (define-key minibuffer-local-map (kbd "<escape>") nil))

  (defcustom esc/minibuffer-exit-hook nil
    "esc's hook to run upon exiting the minibuffer."
    :type         'hook
    :options      '()
    :group        'boil)

  ;;;###autoload
  (defun esc/minibuffer-exit-hook ()
    "esc's hook to run whilst exiting the minibuffer's domain."
    nil)
#+END_SRC

** c-mode-common-hook
#+NAME: c-mode-common-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/c-insert-ifdef-ndebug-printf-string nil
    "Debugging string to insert in \\[esc/c-insert-ifdef-ndebug-printf]."
    :type '(string)
    :options '("printf(\"%s \\n\", __FUNCTION__);")
    :group 'boil)
  (setq esc/c-insert-ifdef-ndebug-printf-string "printf(\"%s \\n\", __FUNCTION__);")

  (defcustom esc/c-mode-common-hook nil
    "esc's code to \\[c-mode-common-hook]."
    :type 'hook
    :options '((setq ff-always-in-other-window t)
               (setq ff-always-try-to-create nil)
               ;(idle-highlight t)
               (autoload 'disaster "disaster")
               (local-set-key (kbd "C-c d") 'disaster)
               (local-set-key (kbd "C-c o") 'ff-find-other-file)
               (local-set-key (kbd "C-M-;") 'esc/yank-displaced-doxygen-comment)
               (local-set-key (kbd "C-c d") 'esc/c-insert-ifdef-ndebug-printf)
               (c-turn-on-eldoc-mode))
    :group 'boil)

  ;;;###autoload
  (defun esc/c-mode-common-hook ()
    "esc's code to \\[c-mode-common-hook]."
    ;(idle-highlight t)
    (autoload 'disaster "disaster")
    (local-set-key (kbd "C-c d") 'disaster)
    (local-set-key (kbd "C-c o") 'ff-find-other-file)
    (local-set-key (kbd "C-c d") 'esc/c-insert-ifdef-ndebug-printf)
    (local-set-key (kbd "C-M-;") 'esc/yank-displaced-doxygen-comment)
    (local-set-key (kbd "C-M-S-u") 'esc/unroll-cc-arguments)
    (c-turn-on-eldoc-mode)
    (setq ff-always-in-other-window t
          ff-always-try-to-create nil))
#+END_SRC
** c++-mode-common-hook
#+NAME: c++-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
    (defcustom esc/c++-mode-hook nil
      "esc's code to \\[c++-mode-hook]."
      :type 'hook
      :options '((setq comment-start "/*")
                 (setq comment-end "*/"))
      :group 'boil)

    ;;;###autoload
    (defun esc/c++-mode-hook ()
      "esc's code to \\[c++-mode-hook]."
      (setq comment-start "/*"
            comment-end "*/"))
#+END_SRC
** emacs-lisp-mode-hook
#+NAME: emacs-lisp-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/emacs-lisp-mode-hook nil
    "esc's code to \\[emacs-lisp-mode-hook]."
    :type         'hook
    :options      '((turn-on-eldoc-mode))
    :group        'boil)

  ;;;###autoload
  (defun esc/emacs-lisp-mode-hook ()
    "esc's code to \\[emacs-lisp-mode-hook]."
    (turn-on-eldoc-mode))
#+END_SRC
** fundamental-mode-hook
#+NAME: fundamental-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/fundamental-mode-hook nil
    "esc's code to \\[fundamental-mode-hook]."
    :type         'hook
    :options      '((autopair-mode -1)
                    (flyspell-mode 1))
    :group        'boil)

  ;;;###autoload
  (defun esc/fundamental-mode-hook ()
    "esc's code to \\[fundamental-mode-hook]."
    (autopair-mode -1)
    (flyspell-mode 1))
#+END_SRC
** eshell-mode-hook
TODO: defcustom
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun esc/eshell-mode-hook ()
    (define-key eshell-mode-map (kbd "C-x C-p") 'eshell-previous-matching-input-from-input)
    (define-key eshell-mode-map (kbd "C-x C-n") 'eshell-next-matching-input-from-input)
    (when (require 'em-smart nil 'noerror)
      (setq eshell-where-to-jump 'begin
            eshell-review-quick-commands nil
            eshell-smart-space-goes-to-end t)))
#+END_SRC
** enh-ruby-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
    (defcustom esc/enh-ruby-mode-hook nil
      "esc's code to \\[enh-ruby-mode-hook]."
      :type         'hook
      :options      '((idle-highlight t))
      :group        'boil)

    ;;;###autoload
    (defun esc/enh-ruby-mode-hook ()
      "esc's code to \\[enh-ruby-mode-hook]."
      ;(idle-highlight t)
      )
#+END_SRC
** erc-mode-hook
#+NAME: erc-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/erc-mode-hook nil
    "esc's code to \\[erc-mode-hook]."
    :type         'hook
    :options      '((autopair-mode -1))
    :group        'boil)

  ;;;###autoload
  (defun esc/erc-mode-hook ()
    "esc's code to \\[erc-mode-hook]."
    (autopair-mode -1))
#+END_SRC
** comint-mode-hook
#+NAME: comint-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom esc/comint-mode-hook nil
    "esc's code to \\[comint-mode-hook]."
    :type         'hook
    :options      '((define-key comint-mode-map "M-p" 'comint-previous-input)
                    (define-key comint-mode-map "M-S-p" 'ace-window))
    :group        'boil)

  ;;;###autoload
  (defun esc/comint-mode-hook ()
    "esc's code to \\[comint-mode-hook]."
    ;; TODO: find the active keymap in comint-mode
    (bind-key "M" 'self-insert-command)
    ;;(define-key comint-mode-map "M-p" 'comint-previous-input)
    ;;(define-key comint-mode-map "M-S-p" 'ace-window)
    )
#+END_SRC
** iedit-mode-hook
TODO: defcustom
#+NAME: iedit-mode-hook
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/iedit-mode-hook ()
    "esc's hook to \\[iedit-mode-hook]."
    (define-key iedit-mode-keymap (kbd "<RET>") 'iedit-mode) ;exit
    ;; Don't go overriding my M-x chord, you hear
    (define-key iedit-mode-keymap (kbd "C-'") 'execute-extended-command))
#+END_SRC

** org-mode-hook
TODO: defcustom
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/org-mode-hook()
    (org-indent-mode)
    (imenu-add-to-menubar "Imenu")
    (local-set-key (kbd "C-M-n") 'outline-next-visible-heading)
    (local-set-key (kbd "C-M-p") 'outline-previous-visible-heading)
    (local-set-key (kbd "C-c C-a") 'org-todo))
#+END_SRC
** big-fringe-mode-hook
TODO: defcustom
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;###autoload
  (defun esc/big-fringe-mode-hook ()
    ;; TODO: copy from ecrosson-mobl
    )
#+END_SRC
* Buffer+
#+BEGIN_SRC emacs-lisp :tangle buffer+.el
  ;;; buffer+.el --- Buffer and window management functions

  ;;; Commentary:
  ;;

  ;;; Code:

  ;;;###autoload
  (defun kill-matching-buffers-no-ask (regexp &optional internal-too)
    "Kill buffers whose name matches the specified REGEXP.
  The optional second argument indicates whether to kill internal buffers too."
    (interactive "sKill buffers matching this regular expression: \nP")
    (dolist (buffer (buffer-list))
      (let ((name (buffer-name buffer)))
        (when (and name (not (string-equal name ""))
                   (or internal-too (/= (aref name 0) ?\s))
                   (string-match regexp name))
          (kill-buffer buffer)))))

  ;;;###autoload
  (defmacro esc/toggle-fullscreen-buffer (win-register toggled-mode-test toggle-command
                                                       &optional
                                                       toggle-command-test
                                                       clear-command)
    "Bring up a temporary buffer in fullscreen mode, or restore the
  previous window configuration.

  WIN-REGISTER         is the register to store the old window configuration in.

  TOGGLED-MODE-TEST    is the major mode of the toggled state, in other words a
                       test to determine which way to toggle the buffers.

  TOGGLE-COMMAND       is the command to run when toggling into the temporary
                       state.

  CLEAR-COMMAND        is an optional command to run when reverting back to the
                       original state; i.e. toggle a flag"
    (declare (indent defun))
    `(progn
       (if ,toggled-mode-test
           (progn (jump-to-register ,win-register)
                  (when (not (equal nil ,clear-command))
                    ,clear-command))
         (window-configuration-to-register ,win-register)
         ,toggle-command
         (delete-other-windows))))

  ;;;###autoload
  (defmacro esc/save-window-configuration (win-register &rest body)
    "Save current window configuration to WIN-REGISTER, run BODY,
  and restory WIN-REGISTER."
    (declare (indent defun))
    `(progn
       (window-configuration-to-register ,win-register)
       (progn ,@body)
       (jump-to-register ,win-register)))

  ;;;###autoload
  (defun esc/should-have-opened-this-in-other-window (&optional COUNT)
    "Returns to the previous buffer in current window, calls
  `other-window', and opens the buffer in the new window.

  COUNT is the number of windows to advance; the argument is passed
  directly to `other-window', so see the documentation for more
  details."
    (interactive)
    (when (equal nil COUNT)
      (setq COUNT 1))
    (let ((target (buffer-name)))
      (switch-to-prev-buffer)
      (other-window COUNT)
      (switch-to-buffer target)))

  ;;;###autoload
  (defun buffers-matching-regexp (regexp &optional names)
    "Return a list of buffers matching REGEXP.

  If NAMES is non-nil, return a list of names (strings) instead of
  buffers."
    (remq nil
          (mapcar (lambda (buf)
                    (let ((name (buffer-name buf)))
                      (when (string-match regexp name)
                        (if names
                            (buffer-name buf)
                          buf))))
                  (buffer-list))))

  ;;;###autoload
  (defun esc/rotate-window-split ()
    "Transform a vertically split window to a horizontally split
  window."
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

  ;;;###autoload
  ;; (defun esc/raise-eshell ()
  ;;   "Bring up a full-screen eshell or restore previous window
  ;; configuration."
  ;;   (interactive)
  ;;   (esc/toggle-fullscreen-buffer :eshell-fullscreen
  ;;     (string= "eshell-mode" major-mode)
  ;;     (eshell)))

  ;;;###autoload
  (defun esc/raise-eshell-in-current-dir ()
    "Bring up a full-screen eshell in the current directory or
  restore previous window configuration."
    (interactive)
    (esc/toggle-fullscreen-buffer
      :eshell-fullscreen
      (string= "eshell-mode" major-mode)
      (when (buffer-file-name)
        (let ((dir (file-name-directory (buffer-file-name))))
          (eshell)
          (insert "cd " dir)
          (with-no-warnings (eshell-send-input))))))

  ;;;###autoload
  (defun esc/raise-magit-status ()
    "Bring up a full-screen magit-status or restore previous
  window configuration.

  This defun will not raise magit if you have merge conflicts in
  the current buffer.

  This defun kills all buffers matching regexp '^*magit: ' upon the
  exit toggle of the fullscreen magit buffer"
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (when (re-search-forward "^<<<<<<< variant" nil 'noerror)
        (error "Resolve merge conflicts first.")))
    (esc/toggle-fullscreen-buffer
      :magit-fullscreen
      (string= "magit-status-mode" major-mode)
      (progn (if (not (buffer-file-name))
                 (message "Buffer not associated with a file")
               (save-buffer)
               (magit-status (file-name-directory (buffer-file-name)))))
      nil (kill-matching-buffers-no-ask "^*magit: ")))

  ;; Thanks sacha! See
  ;; [[http://pages.sachachua.com/.emacs.d/Sacha.html#sec-1-5-1][Sacha
  ;; Chua's Emacs configuration]] for more tips.
  ;;;###autoload
  (defun esc/vsplit-last-buffer (prefix)
    "Split the window vertically and display the previous buffer.
  Argument PREFIX when nil switches the new buffer to the last buffer."
    (interactive "p")
    (split-window-vertically)
    (other-window 1 nil)
    (unless prefix (switch-to-next-buffer)))

  ;;;###autoload
  (defun esc/hsplit-last-buffer (prefix)
    "Split the window horizontally and display the previous buffer.
  Argument PREFIX when nil switches the new buffer to the last buffer."
    (interactive "p")
    (split-window-horizontally)
    (other-window 1 nil)
    (unless prefix (switch-to-next-buffer)))

  (provide 'buffer+)

  ;;; buffer+.el ends here
#+END_SRC
* Emacs+
[[http://emacsredux.com/blog/2015/01/18/clear-comint-buffers/][Clear Comint Buffers - Emacs Redux]]
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  (defun comint-clear-buffer ()
    (interactive)
    (let ((comint-buffer-maximum-size 0))
      (comint-truncate-buffer)))
#+END_SRC

Many thanks to [[http://www.emacswiki.org/emacs/DictMode][EmacsWiki]].
#+BEGIN_SRC emacs-lisp :tangle emacs+.el
  ;;;###autoload
  (defun esc/dictionary-search ()
    (interactive)
    (require 'dictionary)
    (let ((word (current-word))
          (enable-recursive-minibuffers t)
          (val))
      (setq val (read-from-minibuffer
                 (concat "Word"
                         (when word
                           (concat " (" word ")"))
                         ": ")))
      (dictionary-new-search
       (cons (cond
              ((and (equal val "") word)
               word)
              ((> (length val) 0)
               val)
              (t
               (error "No word to lookup")))
             dictionary-default-dictionary))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle emacs+.el
    ;;;###autoload
    (defun esc/insert-numeric-sequence ()
      "Insert a sequence of numbers at point, separated by spaces. Inclusive."
      (interactive)
      (let ((begin (read-number "Begin: "))
            (end (read-number "End: ")))
        (dotimes (i (- (+ 1 end) begin))
          (insert (number-to-string (+ i begin)))
          (insert " "))))

    (defun esc/insert-time ()
      "Insert string for the current time formatted as '21:25'."
      (interactive)
      (insert (format-time-string "%H:%M")))

    ;;;###autoload
    (defun esc/insert-date (prefix)
      "Insert the current date. With prefix-argument, use ISO format. With
       two prefix arguments, write out the day and month name."
      (interactive "P")
      (let ((format (cond
                     ((not prefix) "%Y-%m-%d")
                     ((equal prefix '(4)) "%Y.%m.%d")
                     ((equal prefix '(16)) "%A, %d. %B %Y")))
            (system-time-locale "en_US"))
        (insert (format-time-string format))))

    ;;;###autoload
    (defun esc/get-buffers-matching-mode (mode)
      "Returns a list of buffers where their major-mode is equal to MODE."
      (let ((buffer-mode-matches '()))
        (dolist (buf (buffer-list))
          (with-current-buffer buf
            (if (eq mode major-mode)
                (add-to-list 'buffer-mode-matches buf))))
        buffer-mode-matches))

    ;;;###autoload
    (defun esc/unroll-cc-arguments ()
      "Unroll a function's arguments into a more readable
      one-per-line format. Be sure to invoke this defun from before the
      opening paren of the function's arguments.

      This function has delimeters based on cc-mode dialects, and as a
      result would not be very useful for a language like Lisp."
      (interactive)
      (let ((limit (save-excursion
                     (search-forward "(")
                     (backward-char)
                     (forward-sexp)
                     (point))))
        (save-excursion
          (while (and (< (point) limit)
                      (re-search-forward "[,\"]" limit t))
            (cond ((char-equal ?, (char-before))
                   (newline-and-indent))
                  ((char-equal ?\" (char-before))
                   (re-search-forward "\""))))))
      (message "done"))

    ;;;###autoload
    (defun esc/swap-buffer-locations ()
      "Rotate your windows around and around."
      (interactive)
      (if (not (> (count-windows) 1))
          (error "You can't rotate a single window"))
      (let ((i 1))
        (let ((numWindows (count-windows)))
          (while  (< i numWindows)
            (let* ((w1 (elt (window-list) i))
                   (w2 (elt (window-list) (+ (% i numWindows) 1)))
                   (b1 (window-buffer w1))
                   (b2 (window-buffer w2))
                   (s1 (window-start w1))
                   (s2 (window-start w2)))
              (set-window-buffer w1  b2)
              (set-window-buffer w2 b1)
              (set-window-start w1 s2)
              (set-window-start w2 s1)
              (setq i (1+ i)))))))

    ;;;###autoload
    (defun esc/eval-and-replace (&optional arg)
      "Replace the preceding sexp with its value."
      (interactive "P")
      (backward-kill-sexp)
      (let ((expression (current-kill 0)))
        (condition-case nil
            (progn
              (when arg (insert (concat expression " = ")))
              (prin1 (eval (read expression))
                     (current-buffer)))
          (error (message "Invalid expression")
                 (insert expression)))))

    ;;;###autoload
    (defun esc/save-buffers-kill-emacs (&optional arg)
      "Offer to save each buffer(once only), then kill this Emacs process.
       With prefix ARG, silently save all file-visiting buffers, then kill."
      (interactive "P")
      (save-some-buffers arg t)
      (and (or (not (fboundp 'process-list))
               (let ((processes (process-list)) ;process-list is not defined on DOS
                     active)
                 (while processes
                   (and (memq (process-status (car processes))
                              '(run stop open listen))
                        (process-query-on-exit-flag (car processes))
                        (setq active t))
                   (setq processes (cdr processes)))
                 (or (not active)
                     (progn (list-processes t)
                            (yes-or-no-p
                             "Active processes exist; kill them and exit anyway? ")))))
           ;; Query the user for other things, perhaps.
           (run-hook-with-args-until-failure 'kill-emacs-query-functions)
           (or (null confirm-kill-emacs)
               (funcall confirm-kill-emacs "Really exit Emacs? "))
           (kill-emacs)))

    ;;;###autoload
    (defun esc/mode-line-other-buffer-other-window ()
      "Switch to `other-window', use `mode-line-other-buffer', and
        switch back to the original window."
      (interactive)
      (other-window 1)
      (mode-line-other-buffer)
      (other-window -1))

    (provide 'emacs+)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (provide 'boilerplate)
#+END_SRC

* [0/2] TODOs
** [0/1] org
*** TODO C-. to bury until current-buffer isn't in org-agenda-files
or possibly cycle through your init files
