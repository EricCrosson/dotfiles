#+author: Eric Crosson
#+email: esc@ericcrosson.com
#+todo: TODO(t) VERIFY(v) IN-PROGRESS(p) | OPTIONAL(o) HIATUS(h) DONE(d) DISCARDED(c) HACKED(k)
#+startup: content
* init.el
** Introduction
#+BEGIN_SRC emacs-lisp :tangle yes
    ;;; .emacs.el

    ;;; Commentary:
    ;;; This is the .emacs file written and used by esc. The .el file is
    ;;; not the original form of this document; it was written in org
    ;;; babel. If you are not viewing the org document, you should try to
    ;;; locate it. It's much nicer to humans.

    ;;; License:
    ;;; esc's .emacs configuration file, for a smoother Emacs experience.
    ;;; Copyright (C) 2013 Eric Crosson
    ;;;
    ;;; This program is free software: you can redistribute it and/or modify
    ;;; it under the terms of the GNU General Public License as published by
    ;;; the Free Software Foundation, either version 3 of the License, or
    ;;; (at your option) any later version.
    ;;;
    ;;; This program is distributed in the hope that it will be useful,
    ;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
    ;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    ;;; GNU General Public License for more details.
    ;;;
    ;;; You should have received a copy of the GNU General Public License
    ;;; along with this program. If not, see <http://www.gnu.org/licenses/>.

    ;;; Code:
#+END_SRC

** Load path
This is a neat trick I found to take away 99.9% of the headache when
dealing with Emacs' load path. Assuming the user has placed every
file, script and dependency in his or her =~/.emacs.d/= directory,
this block will ensure Emacs can find each file come load time. No
need to keep the list updated, just load all subdirectories and go.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom site-lisp-path nil
    "Path to esc's lisp library."
    :type 'path
    :options '("~/.emacs.d/site-lisp/")
    :group 'esc-mode)
  (setq site-lisp-path "~/.emacs.d/site-lisp/")

  (defcustom esc-lisp-path nil
    "Path to esc's lisp library."
    :type 'path
    :options '("~/.emacs.d/site-lisp/esc-lisp/")
    :group 'esc-mode)
  (setq esc-lisp-path (concat site-lisp-path "esc-lisp/"))

  (defcustom esc-loaddefs-path nil
    "Path to `loaddefs.el' file used by esc's Emacs sessions."
    :type 'path
    :options '("~/.emacs.d/site-lisp/esc-lisp/loaddefs.el")
    :group 'esc-mode)
  (setq esc-loaddefs-path (concat esc-lisp-path "loaddefs.el"))

  (defcustom esc-meta-path nil
    "Path to .emacs.d meta directory, for internal bookkeeping
  records."
    :type 'path
    :options '("~/.emacs.d/meta")
    :group 'esc-mode)
  (setq esc-meta-path "~/.emacs.d/meta")

  (let ((default-directory site-lisp-path))      ;for easy
    (normal-top-level-add-to-load-path '("."))   ;recursive
    (normal-top-level-add-subdirs-to-load-path)) ;loading

  (autoload 'list-files-in-subtree-matching-regexp-recursive
    (concat esc-lisp-path "update-autoloads.el"))
  ;; Load all project's loaddefs.el (automatically managed)
  (mapc (lambda (loaddef) (load-file loaddef))
        (list-files-in-subtree-matching-regexp-recursive
         esc-lisp-path "loaddefs.el"))
#+END_SRC

Use [[https://github.com/jwiegley/use-package][use-package]]
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'use-package)
#+END_SRC

Set up [[https://github.com/tarsius/auto-compile][auto-compile mode]] to compile source files before loading iff
source is newer than the presently compiled file. A good tradeoff
with proper distributed version control.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auto-compile
    :init
    (setq load-prefer-newer t)
    (auto-compile-on-load-mode 1))
#+END_SRC

** UI
Now that the legal stuff is out of the way, let's get out the rat poison.
#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc (lambda (mode) (when (fboundp mode) (funcall mode -1)))
        '(menu-bar-mode
          tool-bar-mode
          scroll-bar-mode))
#+END_SRC

Fire up the mood lighting
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bliss-theme
    ;; TODO: switch with color-theme stack
    :config (load-theme 'bliss t))

  ;; TODO: rehook on color change to bliss
  (mapcar (lambda (data) (set-face-attribute (car data) nil
                                        :underline  nil
                                        :foreground 'unspecified
                                        :background (cadr data)))
          '((highlight "#333")
            (region    "#444")))


#+END_SRC
** Macros
I took the macro below from [[http://milkbox.net/note/single-file-master-emacs-configuration/][milkypostman]]. His article is really worth
a read; stop what you're doing and go take a look if you haven't.
#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro after (mode &rest body)
  "`eval-after-load' MODE evaluate BODY."
  (declare (indent defun))
  `(eval-after-load ,mode
     '(progn ,@body)))
#+END_SRC

A macro to wrap code execution in those handy =*Messages*= style
notifications.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro message-progress (message &rest body)
    "Message MESSAGE and run BODY. Then message MESSSAGE...done."
    (declare (indent defun))
    `(progn
       (message ,message)
       (progn ,@body)
       (message (concat ,message "...done"))))
#+END_SRC

Facilitate normal initialization processes.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro autoload-from-package (package functions)
    "From PACKAGE (string), autoload FUNCTIONS (list)."
    (declare (indent defun))
    `(mapc (lambda (fn) (autoload fn ,package nil t))
           ,functions))

  (defmacro require-package (packages)
    "Require PACKAGES (list) quietly."
    (declare (indent defun))
    `(mapc (lambda (package) (require package nil 'noerror))
           ,packages))
#+END_SRC

** Package configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package package
    :config
    (setq package-user-dir (concat site-lisp-path "elpa/"))
    (mapc (lambda (source) (add-to-list 'package-archives source) t)
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("marmalade" . "http://marmalade-repo.org/packages/")
            ("melpa-stable" . "http://melpa-stable.milkbox.net/packages/")
            ("melpa" . "http://melpa.milkbox.net/packages/")
            ("org" . "http://orgmode.org/elpa/")))
    (package-initialize))
#+END_SRC

** User metadata
Hello, My Name Is
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq user-full-name "Eric Crosson"
        user-mail-address "esc@ericcrosson.com")
#+END_SRC

** Behavioral modifications
#+BEGIN_SRC emacs-lisp :tangle yes
  (put 'overwrite-mode 'disabled t)       ;There shall be no 'insert'
  (fset 'yes-or-no-p 'y-or-n-p)           ;change yes-no to y-n
  (setq-default size-indication-mode t)
  (setq debug-on-error t
        inhibit-startup-screen t
        initial-scratch-message nil
        ring-bell-function 'ignore        ;turn off alarms completely
        disabled-command-function 'beep   ;alert me when accessing disabled funcs
        redisplay-dont-pause t            ;don't pause refreshes
        frame-title-format '("emacs@" system-name ":%f") ;include path of frame
        display-time-load-average-threshold 0.6
        dabbrev-case-replace nil
        display-buffer-reuse-frames t     ;raise buffers, not spawn
        remote-file-name-inhibit-cache t  ;don't resolve remote file attrubutes
        auto-save-default nil
        large-file-warning-threshold nil
        set-mark-command-repeat-pop t
        starttls-use-gnutls t
        browse-url-browser-function 'browse-web
        kill-buffer-query-functions (remq 'process-kill-buffer-query-function
                                           kill-buffer-query-functions))
#+END_SRC

Now everybody agrees that the =*Minibuffer*= prompt is uneditable.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq minibuffer-prompt-properties '(read-only t point-entered
                                                 minibuffer-avoid-prompt face
                                                 minibuffer-prompt))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  ()
#+END_SRC

Line numbers, when visible, should be loaded after a short delay and
not loaded eagerly. They're candy, and who spends resources acquiring
candy?
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq linum-delay t
        linum-eager nil)
#+END_SRC

These settings keep the text soup that is GNU/Linux as happy as
GNU/Linux files can be.
#+NAME: char-and-font-encoding
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Char and font encoding
  (set-buffer-file-coding-system 'unix)   ;Unix mode. Always
  (setq c-default-style "linux"
        c-basic-offset 4
        require-final-newline 'visit-save ;compliance
        indent-tabs-mode nil
        comment-style 'indent)
#+END_SRC

It is my belief that backup files should not be so obtrusive as to
tempt users to disable them.
#+NAME: stash-backups
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Backup settings
  (push '("." . "~/.config/.emacs.d/") backup-directory-alist)
  (desktop-save-mode 1)                   ;use desktop file
  (setq ;desktop-save 'if-exists           ;save open buffers
        desktop-path '("~/.emacs.d/meta/desktop/") ;local desktop files
        desktop-base-filename "default"
        desktop-load-locked-desktop t     ;never freeze after crash
        backup-by-copying-when-linked t
        backup-by-copying-when-mismatch t)
#+END_SRC

=i-search= is capable of spanning whitespace regions
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq search-whitespace-regexp "[ \t\r\n]+")
#+END_SRC
** Aliases
I did not grow up in an era where this is a straightforward mnemonic.
#+NAME: alias fmakunbound => undefun
#+BEGIN_SRC emacs-lisp :tangle yes
  (defalias 'undefun 'fmakunbound)
#+END_SRC

** Advice
*** builtim command advice
The following macro is to prevent the user from manually having to
create directories (=M-x make-directory RET RET=) after using
=find-file= on a nonexistent file.
#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice find-file (before make-directory-maybe
			     (filename &optional wildcards) activate)
  "Create nonexistent parent directories while visiting files."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
    "Kill `term-mode' buffers when an exit signal is received."
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))
#+END_SRC

*** comment-dwim
I wrote a post about my path to this advice somewhere. I'll find a link when it's stable.
#+NAME: One Commenter to Rule Them All (TM)
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice comment-dwim (around comment-line-maybe activate)
    "If invoked from the beginning of a line or the beginning of
  text on a line, comment the current line instead of appending a
  comment to the line."
    (if (and (not (use-region-p))
             (not (eq (line-end-position)
                      (save-excursion (back-to-indentation) (point))))
             (or (eq (point) (line-beginning-position))
                 (eq (point) (save-excursion (back-to-indentation) (point)))))
        (comment-or-uncomment-region (line-beginning-position)
                                     (line-end-position))
      ad-do-it
      (setq deactivate-mark nil)))
#+END_SRC

Prefix '0' to comment-dwim to kill comments entirely.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice comment-dwim (around delete-comment-if-prefixed activate)
    "If the universal prefix to \\[comment-dwim] is 0, delete the
    comment from the current line or marked region."
    (if (not (eq current-prefix-arg 0))   ; normal behavior
        ad-do-it
      (let ((comments (if (region-active-p)
                          (count-lines (region-beginning) (region-end))
                        1)))
        (save-excursion
          (when (region-active-p)
            (goto-char (region-beginning)))
          (comment-kill comments)))))
#+END_SRC

TODO: write about how cool this is! (not related to above comment
about a post)

** Package initialization
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;(use-package cl-lib) ;; todo is: this necessary?
  ;;(use-package eldoc) ;; TODO: hook onto lisp modes
#+END_SRC
** Configuration
*** Save hist config
Keep a history of =M-x= across sessions.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package savehist
    :config
    (setq savehist-file (concat user-emacs-directory "meta/savehist"))
    (setq savehist-save-minibuffer-history 1)
    (setq savehist-additional-variables
          '(kill-ring
            search-ring
            regexp-search-ring))
    (savehist-mode 1))
#+END_SRC
*** undo-tree config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :config
    ;;; Make zipped files obvious.
    (defadvice undo-tree-make-history-save-file-name
        (after undo-tree activate)
      (setq ad-return-value (concat ad-return-value ".gz")))

    ;;; Thanks to
    ;;; [[http://whattheemacsd.com/my-misc.el-02.html][Magnar]] for the
    ;;; advice.
    (defadvice undo-tree-undo (around keep-region activate)
      (if (use-region-p)
          (let ((m (set-marker (make-marker) (mark)))
                (p (set-marker (make-marker) (point))))
            ad-do-it
            (goto-char p)
            (set-mark m)
            (set-marker p nil)
            (set-marker m nil))
        ad-do-it)))
#+END_SRC
*** esc mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package esc-mode)
#+END_SRC
*** Displaced yank config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package displaced-yank
    :init
    ;; todo: load with use-package displaced yank
    ;; esc delimeter and line hacks
      (bind-key "C-<backspace>" 'backward-delete-word        esc-mode-map)
      (bind-key "C-M--"  'esc/yank-displaced-little-arrow    esc-mode-map)
      (bind-key "C-M-j"  'esc/yank-displaced-parens          esc-mode-map)
      (bind-key "C-M-k"  'esc/yank-displaced-braces          esc-mode-map)
      (bind-key "C-M-|"  'esc/yank-displaced-pipes           esc-mode-map)
      (bind-key "C-M-l"  'esc/yank-displaced-brackets        esc-mode-map)
      (bind-key "C-M-,"  'esc/yank-displaced-chevrons        esc-mode-map)
      (bind-key "C-M-'"  'esc/yank-displaced-single-quotes   esc-mode-map)
      (bind-key "C-M-\"" 'esc/yank-displaced-quotes          esc-mode-map)
      (bind-key "C-M-g"  'esc/yank-displaced-dollars         esc-mode-map)
      (bind-key "C-M-;"  'esc/yank-displaced-stars           esc-mode-map)
      (bind-key "C-M-:"  'esc/yank-displaced-doxygen-comment esc-mode-map)
      (bind-key "C-M-="  'esc/yank-displaced-equals          esc-mode-map)
      (bind-key "C-M-`"  'esc/yank-displaced-ticks           esc-mode-map))
#+END_SRC
*** Powerline config
That's right, it's [[http://2.media.bustedtees.cvcdn.com/e/-/bustedtees.09c737ee-d77b-45da-ac5c-b9bbb562.gif][Power⚡Line]] baby!
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package powerline)
#+END_SRC
*** Smartrep conf
I don't know where smartrep defines keys but this worked for me and I
haven't had to look at it yet.
#+BEGIN_SRC emacs-lisp :tangle no
  (smartrep-define-key global-map "C-c ."
    '(("+" . apply-operation-to-number-at-point)
      ("-" . apply-operation-to-number-at-point)
      ("*" . apply-operation-to-number-at-point)
      ("/" . apply-operation-to-number-at-point)
      ("\\" . apply-operation-to-number-at-point)
      ("^" . apply-operation-to-number-at-point)
      ("<" . apply-operation-to-number-at-point)
      (">" . apply-operation-to-number-at-point)
      ("#" . apply-operation-to-number-at-point)
      ("%" . apply-operation-to-number-at-point)
      ("'" . operate-on-number-at-point)))
#+END_SRC
*** Toggle quotes conf
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package toggle-quotes
    :init (bind-key "M-'" 'toggle-quotes esc-mode-map))
#+END_SRC
*** Goto last change conf
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package goto-last-change
    :init
    (bind-key "C-c /" 'goto-last-change esc-mode-map))
#+END_SRC
*** Which func config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-func
    :config (mapc (lambda (mode) (add-to-list 'which-func-modes mode))
                  '(;org-mode
                    emacs-lisp-mode
                    c-mode
                    c++-mode
                    java-mode
                    ruby-mode
                    enh-ruby-mode)))
#+END_SRC
*** Midnight config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package midnight
    :config (midnight-delay-set 'midnight-delay "5:00am"))
#+END_SRC
*** Unselectable buffer config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package unselectable-buffer)
#+END_SRC
*** Dedicated buffer config
My dedicated mode, not the melpa one
TODO: expand on that
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dedicated-buffer)
#+END_SRC
*** Lua mode config
Gotta love that [[http://awesome.naquadah.org/][awesome wm]]
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package lua-mode
    :mode "\\.lua$"
    :interpreter "lua")
#+END_SRC

*** Auto complete config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auto-complete
    :commands global-auto-complete-mode
    :init
    (setq ac-comphist-file (format "%s/ac-comphist.dat" esc-meta-path))
    (global-auto-complete-mode t)

    :config
    (ac-config-default)
    (setq-default ac-auto-show-menu .1)
    (setq-default ac-sources (append '(ac-source-imenu) ac-sources))
    (add-to-list 'ac-dictionary-directories
                 "~/.emacs.d/auto-complete/ac-dict"))
#+END_SRC
*** Spray config
This mode is based on [[https://github.com/Miserlou/Glance-Bookmarklet][OpenSpritz]], a speedreading tutor.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package spray
    :commands spray-mode)
#+END_SRC

*** ibuffer config
TODO: use-package this guy
Modify ibuffer view to include human readable size information.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Use human readable Size column instead of original one
  (after 'ibuffer
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 100000)  (format "%7.0fk" (/ (buffer-size) 1000.0)))
       ((> (buffer-size) 1000)    (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))

    (setq ibuffer-formats
          '((mark modified read-only         " "
                  (name 18 18  :left :elide) " "
                  (size-h 9 -1 :right)       " "
                  (mode 16 16  :left :elide) " "
                  filename-and-process))))
#+END_SRC

ibuffer-vc is great; make it automatic.
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'ibuffer-vc-autoloads
    (defun esc/ibuffer-vc-refresh ()
      (ibuffer-vc-set-filter-groups-by-vc-root)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    (add-hook 'ibuffer-hook 'esc/ibuffer-vc-refresh))
#+END_SRC

Include vc status info in the buffer list.
Mabye I'll include this one day, for now it can live in hibernation.
#+BEGIN_SRC emacs-lisp :tangle no
  (after 'ibuffer-vc-autoloads
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 18 18 :left :elide)         " "
                  (size 9 -1  :right)               " "
                  (mode 16 16 :left :elide)         " "
                  (vc-status 16 16 :left)           " "
                  filename-and-process))))
#+END_SRC

*** Tea-time config
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package tea-time
    :commands tea-time
    :config
    (defun esc/notify-tea-steeped ()
      (notifications-notify :title "Tea time"
                            :body "Rip out that sac, because your tea bag is done"
                            :app-name "Tea Time"
                            :sound-name "alarm-clock-elapsed"))
    (add-hook 'tea-time-notification-hook 'esc/notify-tea-steeped))
#+END_SRC
*** Scroll all mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mwheel-scroll-up-function   'mwheel-scroll-all-scroll-up-all
        mwheel-scroll-down-function 'mwheel-scroll-all-scroll-down-all)
#+END_SRC

*** Very Large File mode config
Configure options for transparent handling of very large files.
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'vlf-integrate
    (vlf-set-batch-size (* 10 1024))    ;1.mb
    (custom-set-variables
     '(vlf-application 'dont-ask)))
#+END_SRC
*** Golden ratio config mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package golden-ratio
    :idle (after 'golden-ratio
            (add-to-list 'golden-ratio-extra-commands 'ace-window))
    :idle-priority 6)
#+END_SRC
*** Conf mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package conf-mode
    :mode "\\.\\(screenrc\\)\\'")
#+END_SRC
*** Web mode config
TODO: disable autopair-mode for web-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package web-mode
    :mode "\\.jsp$"
    :mode "\\.html$")
#+END_SRC
*** C config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package cc-mode
    :init (setq ff-search-directories '("." "../inc" "../src"))
    :config
    (use-package c++-mode :mode "\\.tcc$")
    (use-package c-eldoc
      :config
      (setq c-eldoc-includes "`pkg-config gtk+-2.0 --cflags` -I./ -I../ ")))
#+END_SRC
*** FIC-mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package fic-mode
    :idle (add-hook 'prog-mode-hook 'turn-on-fic-mode)
    :idle-priority 4)
#+END_SRC
*** Saveplace config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package saveplace
    :config
    (setq-default save-place t)
    (setq save-place-file (format "%s/places" esc-meta-path)))
#+END_SRC
*** Xorg yank config
TODO: turn this into a minor mode for toggling with =esc-mode=
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq x-select-enable-clipboard t       ;global clipboard
        mouse-yank-at-point t)
#+END_SRC
*** Compilation config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq compile-command "make -k -j32"
          compilation-ask-about-save nil
          compilation-save-buffers-predicate '(lambda () nil)) ;never ask to save
#+END_SRC
TODO : associate with =esc-mode=
#+BEGIN_SRC emacs-lisp :tangle yes
  (bury-successful-compilation 1)
#+END_SRC
*** Byte compilation config
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Diminish compiler warnings
  (setq byte-compile-warnings '(not interactive-only free-vars))
  (add-hook 'after-save-hook 'esc/auto-byte-recompile)
#+END_SRC
*** Recentf config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package recentf
    :pre-load (setq recentf-auto-cleanup 'never)
    :config (setq recentf-max-menu-items 50
                  recentf-max-saved-items 50
                  recentf-save-file (format "%s/recentf" esc-meta-path)
                  recentf-keep '(file-remote-p file-readable-p)))
#+END_SRC
*** LaTeX config
Sounded like a good idea thanks to [[http://orgmode.org/worg/org-tutorials/org-latex-export.html][orgmode.com]]
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package latex
    :commands latex-mode
    :config
    (use-package writegood-mode)
    (load "auctex.el" nil t t)
    ;;(load "preview-latex.el" nil t t)
    (setq TeX-command-default "latex"
          TeX-auto-save t
          TeX-parse-self t
          TeX-PDF-mode t
          latex-run-command "pdflatex")
    ;; (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (local-set-key (kbd "C-c C-s") 'latex-math-preview-expression))
#+END_SRC

*** Flyspell mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flyspell
    :config (setq flyspell-issue-message-flag nil))
#+END_SRC
*** Doc view mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'doc-view-mode
    (setq doc-view-continuous t))
#+END_SRC
*** Abbrev mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package abbrev
    :config
    (setq abbrev-file-name "~/emacs.d/abbrev.lst" save-abbrevs t)
    (if (file-exists-p abbrev-file-name) ;load custom abbrevs
        (quietly-read-abbrev-file)))
#+END_SRC
*** Idle highlight config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package idle-highlight
    :disabled t
    :config (setq-default idle-highlight-idle-time 10.0))
#+END_SRC
*** Uniquify config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package uniquify
    :pre-load (setq uniquify-separator ":"
                    uniquify-buffer-name-style 'post-forward))
#+END_SRC
*** Ido config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido
    :config (setq ido-everywhere t                             ;always Ido
                  ido-enable-flex-matching t                   ;smarter Ido
                  ido-create-new-buffer 'always                ;quieter Ido
                  ido-create-new-buffer 'always
                  ido-save-directory-list-file (format "%s/ido.last" esc-meta-path)
                  ido-file-extensions-order '(".org" ".el" ".c" ".c" ".dox" ".txt")))

  (use-package ido-extras
    :init
    (bind-key "M-i"     'ido-goto-symbol  esc-mode-map)
    (bind-key "C-x C-r" 'ido-recentf-open esc-mode-map)
    (bind-key "C-x C-b" 'ido-switch-buffer-current-major-mode esc-mode-map))
#+END_SRC
*** Git gutter+ config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-gutter+
    :disabled t
    :config
    ;; Jump between hunks
    (define-key git-gutter+-mode-map (kbd "C-x n") 'git-gutter+-next-hunk)
    (define-key git-gutter+-mode-map (kbd "C-x p") 'git-gutter+-previous-hunk)
    ;; Act on hunks
    (define-key git-gutter+-mode-map (kbd "C-x v =") 'git-gutter+-show-hunk)
    ;; Stage hunk at point.
    ;; If region is active, stage all hunk lines within the region.
    (define-key git-gutter+-mode-map (kbd "C-x s") 'git-gutter+-stage-hunks)
    (define-key git-gutter+-mode-map (kbd "C-x c") 'git-gutter+-commit)
    (define-key git-gutter+-mode-map (kbd "C-x C") 'git-gutter+-stage-and-commit))
#+END_SRC
*** Multiple cursors config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :config (setq mc/list-file "~/.emacs.d/meta/.mc-lists.el"))
#+END_SRC
*** Spotify config
TODO: idle-load this package after =esc-mode=
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package spotify
    :commands spotify-enable-song-notifications)
#+END_SRC
*** Ace config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-jump-mode
    :init
    ;; todo: hydratize?
    (bind-key "C-c SPC" 'ace-jump-mode esc-mode-map)
    (bind-key "C-x SPC" 'ace-jump-mode-pop-mark esc-mode-map)
    (bind-key "C-M-S-l" 'ace-jump-buffer esc-mode-map)
    :config (ace-jump-mode-enable-mark-sync))
  (use-package ace-window
    :config (setq aw-keys (number-sequence 97 (+ 97 26))))
#+END_SRC
*** Git messenger config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-messenger
    :init
    (bind-key "C-c [" 'git-messenger:popup-message esc-mode-map))
#+END_SRC
*** Keyfreq mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package keyfreq
    :config (keyfreq-autosave-mode 1)
            (setq keyfreq-file "~/.emacs.d/meta/keyfreq"))
#+END_SRC
*** Browse kill ring config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package browse-kill-ring
    :config
    (setq kill-ring-max 80)
    (browse-kill-ring-default-keybindings))
#+END_SRC
*** Clipmon config
TODO: conform to use-packages way of creating stubs
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package clipmon
    :pre-load (defvar clipmon--autoinsert " clipmon--autoinserted-this"))
#+END_SRC
*** Mouse avoidance config
#+BEGIN_SRC emacs-lisp :tangle yes
  (mouse-avoidance-mode 'exile)
#+END_SRC
*** Bitly config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bitly
    :pre-load (autoload 'json-read "json.el")
    :config
    (setq bitly-access-token "b4a5cd4e51df442ab97012cfc2764c599d6eabf8"))
#+END_SRC
*** Paradox config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paradox
    :config
    (setq paradox-execute-asynchronously t
          paradox-automatically-star t
          paradox-github-token "55e6ef08f8952a054f90e588adfe92c94bf4dfd8"))
#+END_SRC
*** Workgroups config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package workgroups
    :config (setq wg-morph-on nil))
#+END_SRC
*** Persp mode conf
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package persp-mode
    :disabled t
    :config
    (setq persp-save-dir (format "%s/persp-confs" esc-meta-path))
    (add-hook 'after-init-hook '(lambda () (persp-mode 1))))
#+END_SRC
*** Haskell mode conf
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package haskell-mode
    :config
    (use-package haskell-indent
      :init (add-hook 'haskell-mode-hook 'haskell-indent-mode)))
#+END_SRC
*** Clean mode line conf
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package clean-mode-line
    :config
    (setq clean-mode-line-alist
          `(;; Major modes
            (enh-ruby-mode . "enh-Rb")
            (ruby-mode   . "Rb")
            (python-mode . "Py")
            (lisp-interaction-mode . "λ")
            (emacs-lisp-mode . "eλ")
            (lisp-mode . "λ"))))
#+END_SRC
*** Pretty lambdada config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package pretty-lambdada
    :idle-priority 6
    :idle (mapc (lambda (prettify-this-mode)
                  (add-hook prettify-this-mode 'pretty-lambda))
                '(emacs-lisp-mode-hook
                  org-mode-hook ;to include source blocks :\
                  enh-ruby-mode-hook
                  ruby-mode-hook)))
#+END_SRC
*** Magit config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :commands magit-status)
#+END_SRC
*** Expand region config
[[http://spw.sdf.org/blog/tech/emacs/expandregionlines.html][Notes from the Library : /blog/tech/emacs/expandregionlines.html]]
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :init  (bind-key "C-;" 'er/expand-region esc-mode-map)
    :config
    (defadvice er/expand-region (around fill-out-region activate)
      (if (or (not (region-active-p))
              (eq last-command 'er/expand-region))
          ad-do-it
        (if (< (point) (mark))
            (let ((beg (point)))
              (goto-char (mark))
              (end-of-line)
              (forward-char 1)
              (push-mark)
              (goto-char beg)
              (beginning-of-line))
          (let ((end (point)))
            (goto-char (mark))
            (beginning-of-line)
            (push-mark)
            (goto-char end)
            (end-of-line)
            (forward-char 1))))))

#+END_SRC
*** Autopair config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package autopair
    :commands autopair-global-mode)
#+END_SRC
*** Diminish mode config
TODO: diminish here with use-package
*** Lexbind config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package lexbind-mode
    :init (add-hook 'emacs-lisp-mode-hook 'lexbind-mode))
#+END_SRC
*** Eshell config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package eshell
    :init (add-hook 'eshell-named-command-hook 'esc/eshell-exec-perl))
#+END_SRC
*** Misc cmds config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package misc
    :commands zap-up-to-char
    :idle ; seeing as I don't use these commands terribly often
    (after 'esc-mode
      (esc-key "M-z"     'zap-up-to-char) ; up-to, life saver
      (esc-key "M-Z"     'zap-to-char)))

  (use-package misc-cmds
    :commands revert-buffer-no-confirm
    :idle ; takes a while to need the get-out-of-jail-free button
    (after 'esc-mode
      (esc-key "C-x M-r" 'revert-buffer-no-confirm)))
#+END_SRC
*** Helm conig
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Helm
  (use-package helm
    :idle-priority 7
    :idle
    (after 'esc-mode
      (esc-keys
        ("C-c i"   . helm-imenu)
        ("C-x C-j" . helm-for-files))))
#+END_SRC
*** Rainbow delimeters mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    ;; TODO: associate with esc-mode
    :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
*** Windmove config
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Windmove from shift keys
  (use-package windmove
    :config (windmove-default-keybindings))
#+END_SRC
*** Fold this config
Thanks yet again [[https://github.com/magnars/fold-this.el][Magnar]]
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package fold-this
    :idle-priority 8
    :idle
    (after 'esc-mode
      (esc-keys
        ("C-c f" . fold-this)
        ("C-c F" . fold-this-unfold-all))))

#+END_SRC
*** Org cliplink config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-cliplink
    :idle
    (after 'esc-mode
      (esc-key "C-c C-M-l" 'org-cliplink)))
#+END_SRC
** Hooks
Attach =esc-mode= hooks
#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc (lambda (hook)
          (let ((attach (intern (format "esc/%s" hook))))
            (add-hook hook attach)))
        '(erc-mode-hook
          prog-mode-hook
          fundamental-mode-hook
          emacs-lisp-mode-hook
          c-mode-common-hook
          c++-mode-hook
          eshell-mode-hook
          iedit-mode-hook
          comint-mode-hook
          big-fringe-mode-hook
          org-mode-hook
          minibuffer-setup-hook
          dired-mode-hook
          dired-load-hook
          multiple-cursors-mode-enabled-hook
          multiple-cursors-mode-disabled-hook))
#+END_SRC

*** Text mode hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
*** Find-file hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'find-file-hook 'esc/remove-dos-eol)
#+END_SRC
*** Save hooks
Handy little hooks to nudge new files in the right direction.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
*** Compilation buffer hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'same-window-buffer-names "*compilation*")
#+END_SRC
*** Change major mode hook
Take this opportunity to refresh the mode line. Inspiration from
[[http://www.masteringemacs.org/article/hiding-replacing-modeline-strings][Hiding and replacing modeline strings with clean-mode-line - Mastering
Emacs]].
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'after-change-major-mode-hook 'clean-mode-line)
#+END_SRC
*** Kill buffer hook
[[http://emacswiki.org/emacs/RecreateScratchBuffer][EmacsWiki: Recreate Scratch Buffer]]
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'kill-buffer-query-functions 'esc/unkillable-scratch-buffer)
#+END_SRC
*** Kill emacs hook
Summon the magical cookies.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'kill-emacs-hook 'update-esc-lisp-autoloads)
#+END_SRC

Override the kill function.
#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'save-buffers-kill-emacs 'esc/save-buffers-kill-emacs)
#+END_SRC

** OS configuration
Operating system-specific configurations take place here, within this
massive =cond=.
#+NAME: Operating System specific configurations
#+BEGIN_SRC emacs-lisp :tangle yes
  (cond ((or (eq system-type 'ms-dos)
             (eq system-type 'windows-nt)
             (eq system-type 'cygwin))

         ;; Windows config
         (message-progress "Loading Windows specific configuration..."
           (setq w32-pass-lwindow-to-system nil
                 w32-pass-rwindow-to-system nil
                 w32-pass-apps-to-system nil
                 w32-lwindow-modifier 'super ; Left Windows key
                 w32-rwindow-modifier 'super ; Right Windows key
                 w32-apps-modifier 'hyper)   ; Menu key
           (require-package '(w32-symlinks))
#+END_SRC

Note: for GNU Emacs compiled for Microsoft, both of the below options
need to be set in order to follow symlinks. The shell snippet tells
cygwin to create symlinks in a friendly format (old links need to be
regenerated with this flag) and the sexp is loaded by Emacs allowing
transparent use of symlinks.

#+BEGIN_SRC sh :tangle no
  # TODO: tangle me
  export CYGWIN="nodosfilewarning winsymlinks"
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (customize-option 'w32-symlinks-handle-shortcuts)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
           ))
#+END_SRC

Begin Mac OS configuration

#+BEGIN_SRC emacs-lisp :tangle yes
         ((or (eq system-type 'darwin))
          (message-progress "Loading Darwin specific configuration..."
            (setq mac-command-modifier 'meta)
            (setq mac-option-modifier 'super)
            (setq ns-function-modifier 'hyper))))
#+END_SRC

** Dired configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired-details
    :idle-priority 6
    :idle
    (dired-details-install)
    (use-package dired-x)
    (use-package dash
      :idle 6
      ;; Reload dired after making changes
      (put '--each 'lisp-indent-function 1)
      (--each '(dired-do-rename
                dired-create-directory
                wdired-abort-changes)
        (eval `(defadvice ,it (after revert-buffer activate)
                 (revert-buffer)))))
    (use-package wdired
      :config
      (define-key wdired-mode-map
        (vector 'remap 'beginning-of-line) 'esc/dired-back-to-start-of-files)
      (define-key wdired-mode-map
        (vector 'remap 'esc/back-to-indentation-or-beginning)
        'esc/dired-back-to-start-of-files)
      (define-key wdired-mode-map
        (vector 'remap 'beginning-of-buffer) 'esc/dired-back-to-top)
      (define-key wdired-mode-map
        (vector 'remap 'end-of-buffer) 'esc/dired-jump-to-bottom)))
#+END_SRC
** org config
My favorite mode. This was the reason I started using Emacs, didja
know?
#+BEGIN_SRC emacs-lisp :tangle yes
    ;; Org mode bindings -- TODO: in use-pcakage


  (use-package org
    :pre-load (setq org-replace-disputed-keys t)
    :idle-priority 2
    :idle
    (setq-default major-mode 'org-mode)  ;default mode for new buffers

    :config
    ;;; org advice -- shrink the agenda buffer and keep it that way
    (defadvice org-agenda (around shrink-agenda-buffer activate)
      "Shrink the agenda after initial display."
      ad-do-it
      (shrink-window-if-larger-than-buffer))

    ;; keep it shrunken upon refresh
    (defadvice org-agenda-redo (around shrink-agenda-buffer-after-refresh activate)
      "Shrink the agenda after refreshing the display."
      ad-do-it
      (shrink-window-if-larger-than-buffer))
    ;;; end org advice

    (setq org-checkbox-hierarchical-statistics nil
          org-hierarchical-todo-statistics nil
          org-hide-emphasis-markers t
          org-src-fontify-natively t
          org-clock-persist 'history
          org-habit-graph-column 55
          org-hide-leading-stars t
          org-directory "~/org"
          org-imenu-depth 3
          org-agenda-files (append '("~/workspace/ee445m-labs/doc/todo.org"
                                     "~/workspace/ee445m-labs/doc/lab-manuals/todo.org"
                                     "~/org/intel.org"
                                     "~/org/todo.org")))
    (after 'esc-mode
      (esc-keys
          ("C-,"     . org-cycle-agenda-files)
          ("C-c a"   . org-agenda)
          ("C-c l l" . org-store-link)))

    (add-to-list 'org-modules 'org-habit)
    (add-to-list 'org-structure-template-alist
                 '("E"
                   "#+BEGIN_SRC emacs-lisp ?\n\n#+END_SRC"
                   "<emacs-lisp>\n?\n</emacs-lisp>"))

    (defun esc/org-confirm-babel ()
      (setq org-confirm-babel-evaluate nil)

      (org-babel-do-load-languages
       'org-babel-load-languages
       '(;; Always execute these languages
         (R               .       t)
         (ditaa           .       t)
         (dot             .       t)
         (plantuml        .       t)
         (emacs-lisp      .       t)
         (lisp            .       t)
         (clojure         .       t)
         (scala           .       t)
         (gnuplot         .       t)
         (haskell         .       t)
         (ocaml           .       t)
         (python          .       t)
         (ruby            .       t)
         (sh              .       t)
         (sqlite          .       t)
         (octave          .       t)
         (plantuml        .       t)
         ;; Never execute these languages
         (screen          .       nil)
         (sql             .       nil))))

    (add-hook 'org-mode-hook 'esc/org-confirm-babel)

    (use-package ox-latex
      ;; optimize: probably possible to optimize use-package's loading
      ;; of the below code
      :init
      ;; Add minted to the defaults packages to include when exporting.
      (add-to-list 'org-latex-packages-alist '("" "minted"))
      ;; Tell the latex export to use the minted package for source
      ;; code coloration.
      (setq org-latex-listings 'minted)
      ;; Let the exporter use the -shell-escape option to let latex
      ;; execute external programs.
      ;; This obviously and can be dangerous to activate!
      (setq org-latex-pdf-process
            '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))))
#+END_SRC
[[http://lists.gnu.org/archive/html/emacs-orgmode/2012-05/msg00708.html][More information on defining your own Easy Templates]].
*** org advice
[[http://emacs.stackexchange.com/a/9347][org mode - How does one use flyspell in org buffers without flyspell
triggeri...]]
As of <2015-02-18 Wed> this advice did not work for me.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; NO spell check for embedded snippets
  (defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
    (let ((rlt ad-return-value)
          (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\)")
          (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\)")
          old-flag
          b e)
      (when ad-return-value
        (save-excursion
          (setq old-flag case-fold-search)
          (setq case-fold-search t)
          (setq b (re-search-backward begin-regexp nil t))
          (if b (setq e (re-search-forward end-regexp nil t)))
          (setq case-fold-search old-flag))
        (if (and b e (< (point) e)) (setq rlt nil)))
      (setq ad-return-value rlt)))
#+END_SRC

*** org babel
#+BEGIN_SRC emacs-lisp :tangle no
  ;;; org-export-blocks-format-plantuml.el Export UML using plantuml
  ;;
  ;; OBSOLETED, use ob-plantuml.el bundled in org instead.
  ;;
  ;; Copy from org-export-blocks-format-ditaa
  ;;
  ;; E.g.
  ;; #+BEGIN_UML
  ;;   Alice -> Bob: Authentication Request
  ;;   Bob --> Alice: Authentication Response
  ;; #+END_UML

  (eval-after-load "org-exp-blocks"
    '(progn
       (add-to-list 'org-export-blocks '(uml iy/org-export-blocks-format-plantuml nil))
       (add-to-list 'org-protecting-blocks "uml")))

  (defvar iy/org-plantuml-jar-path (expand-file-name "~/Dropbox/java-libs/plantuml.jar")
    "Path to the plantuml jar executable.")
  (defun iy/org-export-blocks-format-plantuml (body &rest headers)
    "Pass block BODY to the plantuml utility creating an image.
    Specify the path at which the image should be saved as the first
    element of headers, any additional elements of headers will be
    passed to the plantuml utility as command line arguments."
    (message "plantuml-formatting...")
    (let* ((args (if (cdr headers) (mapconcat 'identity (cdr headers) " ")))
           (data-file (make-temp-file "org-plantuml"))
           (hash (progn
                   (set-text-properties 0 (length body) nil body)
                   (sha1 (prin1-to-string (list body args)))))
           (raw-out-file (if headers (car headers)))
           (out-file-parts (if (string-match "\\(.+\\)\\.\\([^\\.]+\\)$" raw-out-file)
                               (cons (match-string 1 raw-out-file)
                                     (match-string 2 raw-out-file))
                             (cons raw-out-file "png")))
           (out-file (concat (car out-file-parts) "_" hash "." (cdr out-file-parts))))
      (unless (file-exists-p iy/org-plantuml-jar-path)
        (error (format "Could not find plantuml.jar at %s" iy/org-plantuml-jar-path)))
      (setq body (if (string-match "^\\([^:\\|:[^ ]\\)" body)
                     body
                   (mapconcat (lambda (x) (substring x (if (> (length x) 1) 2 1)))
                              (org-split-string body "\n")
                              "\n")))
      (cond
       ((or htmlp latexp docbookp)
        (unless (file-exists-p out-file)
          (mapc ;; remove old hashed versions of this file
           (lambda (file)
             (when (and (string-match (concat (regexp-quote (car out-file-parts))
                                              "_\\([[:alnum:]]+\\)\\."
                                              (regexp-quote (cdr out-file-parts)))
                                      file)
                        (= (length (match-string 1 out-file)) 40))
               (delete-file (expand-file-name file
                                              (file-name-directory out-file)))))
           (directory-files (or (file-name-directory out-file)
                                default-directory)))
          (with-temp-file data-file (insert (concat "@startuml\n" body "\n@enduml")))
          (message (concat "java -jar " iy/org-plantuml-jar-path " -pipe " args))
          (with-temp-buffer
            (call-process-shell-command
             (concat "java -jar " iy/org-plantuml-jar-path " -pipe " args)
             data-file
             '(t nil))
            (write-region nil nil out-file)))
        (format "\n[[file:%s]]\n" out-file))
       (t (concat
           "\n#+BEGIN_EXAMPLE\n"
           body (if (string-match "\n$" body) "" "\n")
           "#+END_EXAMPLE\n")))))

#+END_SRC
*** org beamer
Thanks to [[http://emacs-fu.blogspot.com/2009/10/writing-presentations-with-org-mode-and.html][emacs-fu]]!
#+BEGIN_SRC emacs-lisp :tangle no
  ;; allow for export=>beamer by placing
  ;; #+LaTeX_CLASS: beamer in org files
  (unless (boundp 'org-export-latex-classes)
    (setq org-export-latex-classes nil))
  (add-to-list 'org-export-latex-classes
    ;; beamer class, for presentations
    '("beamer"
       "\\documentclass[11pt]{beamer}\n
        \\mode<{{{beamermode}}}>\n
        \\usetheme{{{{beamertheme}}}}\n
        \\usecolortheme{{{{beamercolortheme}}}}\n
        \\beamertemplateballitem\n
        \\setbeameroption{show notes}
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{hyperref}\n
        \\usepackage{color}
        \\usepackage{listings}
        \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
    frame=single,
    basicstyle=\\small,
    showspaces=false,showstringspaces=false,
    showtabs=false,
    keywordstyle=\\color{blue}\\bfseries,
    commentstyle=\\color{red},
    }\n
        \\usepackage{verbatim}\n
        \\institute{{{{beamerinstitute}}}}\n
         \\subject{{{{beamersubject}}}}\n"

       ("\\section{%s}" . "\\section*{%s}")

       ("\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}"
         "\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}")))

    ;; letter class, for formal letters

    (add-to-list 'org-export-latex-classes

    '("letter"
       "\\documentclass[11pt]{letter}\n
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{color}"

       ("\\section{%s}" . "\\section*{%s}")
       ("\\subsection{%s}" . "\\subsection*{%s}")
       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
       ("\\paragraph{%s}" . "\\paragraph*{%s}")
       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

#+END_SRC
*** org capture
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-default-notes-file (concat org-directory "/capture.org"))
  (after 'org
    (after 'esc-mode
      (esc-key "C-c C-p" 'org-capture)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-capture-templates
        '(;; General tasks go here
          ("t" "Todo" entry
           (file+headline (concat org-directory "/todo.org") "Tasks")
           "* TODO %?\n  %a")
          ;; Used to record my state
          ("j" "Journal" entry
           (file+datetree (concat org-directory "/journal.org"))
           "* %?\nEntered on %U\n  %i\n  %a")

          ;;; Work-related captures
          ("c" "Centaur" entry
           (file+datetree (concat org-directory "/centtech/centtech.org"))
           "* TODO %?\n  %i\n  %a")

          ;;; Personal captures
          ;; Notes about Super Smash Bros. 64
          ("s" "Smash Bros." entry
           (file+headline (concat org-directory "/smash/smash.org") "Notes")
           "* %?\n")))
#+END_SRC

**** org refile
#+BEGIN_SRC emacs-lisp :tangle no
  (setq ;; Work refile locations
   esc-refile-targets-centtech
   `(,(concat org-directory "/centtech/lru.org")
     ,(concat org-directory "/centtech/pse.org")
     ,(concat org-directory "/centtech/newreg.org"))

   ;; Personal refile locations
   esc-refile-targets-smash
   `(,(concat org-directory "/smash/64.org")
     ,(concat org-directory "/smash/melee.org")
     ,(concat org-directory "/smash/pm.org"))

   org-refile-targets '((nil                         :maxlevel . 5)
                        (esc-refile-targets-centtech :maxlevel . 5)
                        (esc-refile-targets-smash    :maxlevel . 5)
                        (org-agenda-files            :maxlevel . 4)))
#+END_SRC

** Fin
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq initial-scratch-message
	 (propertize "Don't\nPanic\n"
		     'font-lock-face '(:height 10.0 :inherit variable-pitch)))
  (message "All done, %s%s" (user-login-name) ".")
  ;;; .emacs.el ends here
#+END_SRC
* esc-lisp
** dired-config
#+NAME: defcustom esc's dired hooks
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/dired-config.el
  (defcustom esc/dired-mode-hook nil
    "esc's hook to add to \\[dired-mode-hook]."
    :type    'hook
    :options '((define-key dired-mode-map (vector 'remap 'beginning-of-buffer) 'esc/dired-back-to-top)
               (define-key dired-mode-map (vector 'remap 'end-of-buffer) 'esc/dired-jump-to-bottom)
               (define-key dired-mode-map (kbd "^") 'esc/dired-up-level-reuse-buffer))
    :group   'esc-dired)

  ;;;###autoload
  (defun esc/dired-mode-hook ()
    "esc's hook to \\[dired-mode-hook]."
    (let ((activate (if (eq major-mode 'dired-mode) 1 -1)))
      (hl-line-mode activate)
      (after 'dired-x (dired-omit-mode activate)))
    (setq-default dired-details-hidden-string "--- "
                  dired-recursive-copies 'always
                  dired-recursive-deletes 'top
                  dired-omit-verbose nil)
    (define-key dired-mode-map (kbd "C-a") 'esc/dired-back-to-start-of-files)
    (define-key dired-mode-map (vector 'remap 'beginning-of-buffer) 'esc/dired-back-to-top)
    (define-key dired-mode-map (vector 'remap 'end-of-buffer) 'esc/dired-jump-to-bottom)
    (define-key dired-mode-map (kbd "^") 'esc/dired-up-level-reuse-buffer))

  (defcustom esc/dired-load-hook nil
    "esc's hook to add to \\[dired-mode-hook]."
    :type    'hook
    :options '((load "dired-x" nil t)
               (setq dired-listing-switches "-alh") ; todo: make friendly
               (esc/dired-load-hook-omit-files))
    :group   'esc-dired)

  ;;;###autoload
  (defun esc/dired-load-hook ()
    "esc's hook to \\[dired-load-hook]."
    (load "dired-x" nil t) ; todo: make friendly
    (setq-default dired-listing-switches "-alh")
    (setq-default dired-recursive-copies 'always)
    (esc/dired-load-hook-omit-files))
#+END_SRC
#+NAME: dired-lib
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/dired-config.el
  ;;;###autoload
  (defun esc/dired-load-hook-omit-files ()
    (setq dired-omit-verbose nil)
    (setq dired-omit-files (concat dired-omit-files "\\|^\\.dropbox$"))
    (after 'undo-tree
      (setq dired-omit-files (concat dired-omit-files "\\|^\\.*~undo-tree~$"))))
#+END_SRC

Thanks [[http://whattheemacsd.com/setup-dired.el-02.html][Magnar]] for all the good ideas.

#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/dired-config.el
  ;;;###autoload
  (defun esc/dired-back-to-top ()
    "Goes to the first line in dired, not the top of the buffer."
    (interactive)
    (beginning-of-buffer)
    (when (not (search-forward ".." nil 'noerror))
      (beginning-of-buffer))          ;likely dired-omit-mode is enabled
    (dired-next-line 1))

  ;;;###autoload
  (defun esc/dired-jump-to-bottom ()
    "Goes to the last line in dired, not the bottom of the buffer."
    (interactive)
    (end-of-buffer)
    (dired-previous-line 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/dired-config.el
  ;;;###autoload
  (defun esc/dired-find-file-single-mode ()
    "This defun will invoke `dired-find-file` and open the file(s) at point in `single-mode'."
    (interactive)
    (dired-find-file)
    (single-mode 1))

  ;;;###autoload
  (defun esc/dired-up-level-reuse-buffer ()
    "This defun will go to the parent directory in dired while reusing the current buffer."
    (interactive)
    (find-alternate-file ".."))

  ;;;###autoload
  (defun esc/search-my-lisp-dir ()
    "Open esc-lisp in `dired' for easy editing of configs."
    (interactive)
    (esc/edit-configs)
    (esc/dired-back-to-top)
    (call-interactively 'isearch-forward))

  ;;;###autoload
  (defun esc/dired-back-to-start-of-files ()
    (interactive)
    (backward-char (- (current-column) 2)))
#+END_SRC
** esc-mode
*** summary
Here lies my personal minor mode, where I confine all of my custom
keybindings. I also hook all of my preferred major and minor modes
onto this mode's activation hook. Though all of my customizations are
active by default for new emacs sessions, one can get back to the
default settings by running =M-x esc-mode=.

What is the difference between my current setup and using
`define-globalized-minor-mode'?
*** esc variables
As a convention, esc functions are prefixed with `esc/' while esc
variables are prefixed with `esc-'
#+NAME: define customizable variables
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defvar esc-mode-map (make-keymap)
      "The keymap for `esc-mode'.")

  ;;;###autoload
  (define-minor-mode esc-mode
      "Toggle esc-keys mode.
                   A minor mode so that my key settings override annoying major modes."
      t " esc" 'esc-mode-map)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  ;; TODO: devise method of keeping these options in sync with the
  ;; entire current implementation of esc/accompanying-mode-hook
  (defcustom esc/accompanying-mode-hook nil
    "Hook that is appended to esc-mode-hook."
    :type         'hook
    :options      '(;; do's
                    (when (fboundp 'ido-mode) (ido-mode (esc-mode-enabledp)))
                    (when (fboundp 'eldoc-mode) (eldoc-mode (esc-mode-enabledp)))
                    (when (fboundp 'winner-mode) (winner-mode (esc-mode-enabledp)))
                    (when (fboundp 'keyfreq-mode) (keyfreq-mode (esc-mode-enabledp)))
                    (when (fboundp 'recentf-mode) (recentf-mode (esc-mode-enabledp)))
                    (when (fboundp 'icomplete-mode) (icomplete-mode (esc-mode-enabledp)))
                    (when (fboundp 'guide-key-mode) (guide-key-mode (esc-mode-enabledp)))
                    (when (fboundp 'auto-fill-mode) (auto-fill-mode (esc-mode-enabledp)))
                    (when (fboundp 'show-paren-mode) (show-paren-mode (esc-mode-enabledp)))
                    (when (fboundp 'line-number-mode) (line-number-mode (esc-mode-enabledp)))
                    (when (fboundp 'display-time-mode) (display-time-mode (esc-mode-enabledp)))
                    (when (fboundp 'column-number-mode) (column-number-mode (esc-mode-enabledp)))
                    (when (fboundp 'which-function-mode) (which-function-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-hl-line-mode) (global-hl-line-mode (esc-mode-enabledp)))
                    (when (fboundp 'display-battery-mode) (display-battery-mode (esc-mode-enabledp)))
                    (when (fboundp 'autopair-global-mode) (autopair-global-mode (esc-mode-enabledp)))
                    (when (fboundp 'auto-compression-mode) (auto-compression-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-on-screen-mode) (global-on-screen-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-font-lock-mode) (global-font-lock-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-auto-revert-mode) (global-auto-revert-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-rainbow-delimiters-mode) (global-rainbow-delimiters-mode (esc-mode-enabledp)))
                    ;; dont's
                    (when (fboundp 'tool-bar-mode) (tool-bar-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'menu-bar-mode) (menu-bar-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'scroll-bar-mode) (scroll-bar-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'blink-cursor-mode) (blink-cursor-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'transient-mark-mode) (transient-mark-mode (dont (esc-mode-enabledp)))))
    :group        'esc-mode)
#+END_SRC

*** esc macros
#+NAME: self inflection
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defmacro esc-mode-enabledp ()
      "A macro to determine if \\[esc-mode] is currently enabled."
      `(progn (and (boundp 'esc-mode) esc-mode)))
#+END_SRC

TODO: integrate this into =esc-mode= again
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
    (after 'diminish-autoloads
      (defmacro diminish-or-restore (mode)
        "A macro to diminish a MODE, if `esc-mode' is being enabled;
              or disable a MODE, if `esc-mode' is being disabled."
        `(progn
           (after 'diminish-autoloads
             (if (esc-mode-enabledp)
                 (diminish ,mode)
               (diminish-undo ,mode))))))
#+END_SRC

Never you mind this macros...
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defmacro dont (operand)
    "A macro to avoid awkward, unintuitive code in \\[esc-accompanying-mode-hook].
            OPERAND is an integer to de/activate a given mode."
    `(progn
       (if (numberp ,operand)
           (* (- 1) ,operand)
         (if ,operand nil t))))
#+END_SRC

Macros to insert bindings in =esc-mode-map=.
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defmacro esc-key (sequence action)
    "A macro to bind SEQUENCE to ACTION in `esc-mode-map'."
    `(define-key esc-mode-map (kbd ,sequence) ,action))

  (defmacro esc-keys (&rest binding-list)
    "A macro to bind all keybindings and functions in BINDING-LIST
  in `esc-mode-map'.

  This macro runs conses through \\[esc-key] for convenience."
    (declare (indent defun))
    `(mapc (lambda (binding) (esc-key (car binding) (cdr binding)))
           '(,@binding-list)))


  ;; TODO: esc-replace-key
  (defmacro esc-replace-key (old-action new-action)
    ""
    `(define-key esc-mode-map (vector 'remap ,old-action) ,new-action))


  ;; TODO: implement a vector remap analog to esc-keys
  (defmacro esc-replace-keys (&rest binding-list)
    ""
    )
#+END_SRC

*** esc bindings
#+NAME: keybindings defined here
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  ;; Remaps -- wherever they may be bound
  (esc-replace-key 'goto-line 'esc/goto-line-with-feedback)
  (esc-replace-key 'split-window-right 'esc/hsplit-last-buffer)
  (esc-replace-key 'split-window-below 'esc/vsplit-last-buffer)

  ;; todo: pull buffer management into another hydra
  ;; Buffer management
  (esc-key "C-x 4 k"    'esc/mode-line-other-buffer-other-window)
  (esc-key "C-x 4 9"    'esc/bury-buffer-delete-window)
  (esc-key "C-c C-M-\\" 'esc/indent-buffer)

  ;; Enhanced keybindings
  (esc-key "C-a"     'esc/back-to-indentation-or-beginning)
  (esc-key "M-s o"   'occur-dwim)

  (esc-key "C-c y" 'esc/middle-click-yank)

  ;; Miscellaneous keybindings
  (esc-key "C-c C-b" 'mode-line-other-buffer)
  (esc-key "M-K"     'kill-sentence)
  (esc-key "M-j"     'just-one-space) ; conflicts with spotlight
  (esc-key "C-c k"   'esc/copy-line)
  (esc-key "M-P"     'align-regexp) ;; TODO: pull aligns into hydra
  (esc-key "C-'"     'query-replace)
  ;; TODO: change sexp wrapping (esc-key i 'e. {}[]()) from Xah Lee

  ;; Programming bindings
  (esc-key "C-c m" 'compile)
  (esc-key "C-c C-m" 'recompile)

  ;; C-q cluster
  (esc-key "C-q" 'delete-region)     ;like C-w, but gone forever.
  (esc-key "C-c q" 'auto-fill-mode)  ;more frequented than
  (esc-key "C-c C-q" 'quoted-insert) ;  this command

  ;; newline creation
  (esc-key "<C-return>"   'esc/open-line-below)
  (esc-key "<C-S-return>" 'esc/open-line-above)
  (esc-key "C-M-O"        'split-line)
  (esc-key "M-k"          'esc/pull-up-line)

  ;; LaTeX bindings
  ;; todo: hydratize that block
  (esc-key "C-c l b" 'esc/insert-latex-block)

   ;; Mark commands
  (esc-key "C-x m" 'pop-to-mark-command)

  ;; Lisp/sexp movement
  (esc-key "C-S-k" 'kill-sexp)

  ;; Buffer control
  (esc-key "C-x M-b" 'bury-buffer)
  (esc-key "C-x M-B" 'esc/bury-other-buffer)
  (esc-key "C-c o" 'clone-indirect-buffer-other-window)
  (esc-key "C-c C-o" 'ff-find-other-file) ;; TODO: only bind in appropriate modes

  ;; todo: hydratize?
  ;; Help+
  (esc-key "C-h C-f" 'find-function)
  (esc-key "C-h C-k" 'find-function-on-key)
  (esc-key "C-h C-v" 'find-variable)
  (esc-key "C-h C-l" 'find-library)
  (esc-key "C-h C-n" 'esc/insert-defun-at-point)
  (esc-key "C-h M-k" 'describe-keymap)
  (esc-key "C-h C-M-c" 'esc/insert-key-combination)
  ;;; todo: rename insert-defun to insert-function
  (esc-key "C-h C-M-f" 'esc/insert-defun-at-point)

    ;;; Function keys
  (esc-key "<f5>"  'esc/minibuffer-display-buffer-file-name)
  (esc-key "<f6>"  'spray-mode)
  (esc-key "<f8>"  'esc/follow-mode-80-char-compliant)
  (esc-key "C-c <f8>" 'esc/hsplit-last-buffer-follow-mode)
  (esc-key "<f9>"  'flyspell-buffer)
  (esc-key "<f10>" 'golden-ratio-mode)
  ;; TODO: create a defun to save win configuration first
  ;; see stack on zebulon

  (esc-key "C-c f" 'esc/visit-favorite-dir)

  ;; Buffer-overlay hacks: super useful!
  ;; TODO: smarter win-restore config
  (esc-key "s-q" 'esc/raise-magit-status)
  (esc-key "s-e" 'esc/raise-eshell)
  ;; todo: raise shell
  ;; todo: smarter magit status: use zebulon's stack package
  ;; todo: save window configuration
#+END_SRC
*** esc hydras
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
    (setq hydra-lv nil)

    (defhydra hydra-spotify (esc-mode-map "<f7>")
      "spotify"
      ("c"   spotify-playpause "play/pause"
       "p"   spotify-previous  "prev"
       "n"   spotify-next      "next"))

    (defhydra hydra-text-scale (esc-mode-map  "<f2>")
      "text-scale"
      ("j" text-scale-decrease "dec")
      ("k" text-scale-increase "inc")
      ("." default-text-scale-increase "default-dec")
      ("," default-text-scale-decrease "default-inc"))

    (defhydra hydra-eval (esc-mode-map "C-c C-e")
      "eval"
      ("r" eval-region "region")
      ("b" eval-buffer "buffer")
      ("s" eval-last-sexp "sexp")
      ("d" eval-defun "defun")
      ("b" edebug-defun "edebug")
      ("p" esc/eval-and-replace "& replace"))

    (defhydra hydra-error (esc-mode-map "M-g")
      "goto-error"
      ("h" first-error "first")
      ("j" next-error "next")
      ("k" previous-error "prev")
      ("l" esc/goto-line-with-feedback "goto-line" :color blue))

    (defhydra hydra-multiple-cursors (esc-mode-map "M-a")
      "multiple-cursors"
      ("l" mc/edit-lines "edit")
      ("n" mc/mark-next-like-this "mark next")
      ("p" mc/mark-previous-like-this "mark prev")
      ("s" mc/sort-regions "sort")
      ("r" mc/reverse-regions "reverse")
      ("e" mc/insert-numbers "enumerate")
      ("*" mc/mark-all-like-this "mark all")
      ("o" mc/mark-all-like-this-dwim "mark all dwim"))

    (defhydra hydra-word-at-point (esc-mode-map "C-S-s")
      "word at point"
      ("r" esc/search-word-backward "search-backward")
      ("s" esc/search-word-forward "search-forward"))

    ;; todo: move to beginning of word in pre hook
    (defhydra hydra-case-word-at-point (esc-mode-map "C-S-l")
      "case word at point"
      ("c" capitalize-word "capitalize")
      ("u" upcase-word "upcase")
      ("l" downcase-word "lowercase"))

    (esc-key "M-m M-m" 'back-to-indentation)
    ;; todo: create a mirror that manipulates `other-buffer'
    (defhydra hydra-scroll-buffer (esc-mode-map "M-m")
      "cursor-movement"
      ("j" scroll-slight-up "up")
      ("k" scroll-slight-down "dw")
      ("s" isearch-forward "i-f" :color blue)
      ("r" isearch-backward "i-r" :color blue)
      ("h" backward-char "back")
      ("l" forward-char "frwd")
      ("n" next-line "next")
      ("p" previous-line "prev")
      ("e" end-of-line "end-ln")
      ("a" beginning-of-line "beg-ln")
      ("d" scroll-up "pg up")
      ("u" scroll-down "pg dn")
      ("q" read-only-mode)
      ("/" goto-last-change "last-chng")
      ("." find-tag "tag")
      ("*" pop-tag-mark "pop-tag"))

    (defhydra hydra-window-adjustment (esc-mode-map "C-z")
      "window adjustment"
      ("r" esc/rotate-window-split "rotate")
      ("p" esc/swap-buffer-locations "swap")
      ("o" esc/should-have-opened-this-in-other-window "other window")
      ("s" unselectable-buffer "selectable")
      ("w" ace-window "ace-window")
      ("d" dedicated-bufer "dedicated")
      ("b" mode-line-other-buffer "mode-line-other-buffer")
      ("u" bury-buffer "bury"))

    ;; TODO: use-package itize
    (after 'org
      (defhydra hydra-org-nav-source-block (esc-mode-map "C-c n")
        "org src block nav"
        ("n" org-jump-next-src-block "next")
        ("p" org-jump-prev-src-block "prev")))

    (defhydra hydra-move-text (esc-mode-map "M-RET")
      "move text"
      ("j" move-text-down "down")
      ("k" move-text-up "up")
      ("h" hide-lines "hide-lines")
      ("r" esc/reveal-all-hidden-lines "reveal all"))

    (defhydra hydra-mnimap (esc-mode-map "C-c M-RET")
      "minimap"
      ("m" minimap-toggle "toggle")
      ("k" minimap-kill "kill" :color blue))
#+END_SRC

*** esc hook
#+NAME: esc-mode-hook
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  ;; The proper definition of `esc-mode-hook'
  (defun esc/accompanying-mode-hook ()
    "esc's customizations added to `esc-mode-hook'."
    (let* ((activate-bool (esc-mode-enabledp))
           (activate (if activate-bool 1 -1)))
        (if activate-bool (powerline-default-theme) (powerline-revert))

        ;; esc-mode wouldn't be complete without these helper modes
        ;; activate these modes
        (mapc (lambda (mode) (when (fboundp mode)
                          (ignore-errors (funcall mode activate))))
              '(ido-mode
                eldoc-mode
                winner-mode
                keyfreq-mode
                recentf-mode
                icomplete-mode
                guide-key-mode
                auto-fill-mode
                show-paren-mode
                line-number-mode
                display-time-mode
                column-number-mode
                which-function-mode
                global-hl-line-mode
                display-battery-mode
                autopair-global-mode
                auto-compression-mode
                global-on-screen-mode
                global-font-lock-mode
                global-auto-revert-mode
                global-rainbow-delimiters-mode))

        ;; deactivate these modes
        (mapc (lambda (mode) (when (fboundp mode)
                          (ignore-errors (funcall mode (dont activate)))))
              '(tool-bar-mode
                menu-bar-mode
                scroll-bar-mode
                blink-cursor-mode
                transient-mark-mode))

        ;; esc-mode enjoys these settings also
        (when (fboundp 'global-git-gutter-mode)
          (global-git-gutter-mode activate-bool))
        (setq-default save-place       activate-bool
                      abbrev-mode      activate-bool
                      auto-revert-mode activate-bool
                      truncate-lines   activate-bool)
        (diminish 'auto-revert-mode)
        (setq
         display-time-24hr-format             activate-bool
         global-auto-revert-non-file-buffers  activate-bool
         next-line-add-newlines               activate-bool
         kill-whole-line                      activate-bool
         vc-follow-symlinks                   activate-bool
         search-highlight                     activate-bool
         query-replace-highlight              activate-bool
         auto-revert-verbose                  (not activate-bool)
         confirm-nonexistent-file-or-buffer   (not activate-bool))

        ;; TODO: this was determined to have a bug in it. Handle the bug
        ;;(setq revert-buffer-function (if (esc-mode-enabledp)
        ;;                                 'revert-buffer-keep-undo
        ;;                               'revert-buffer))

        ;; todo: when you use visual-line-mode enable physical-line-mode
        ;; (global-visual-line-mode activate) ;word wrap by default
        ;; (diminish 'visual-line-mode)

        (after 'undo-tree-autoloads
          (global-undo-tree-mode activate)
          (setq undo-tree-visualizer-timestamps t
                undo-tree-visualizer-relative-timestamps t))

        ;; less clutter on the mode line
        (after 'test-mode (diminish 'test-mode))
        (diminish 'auto-fill-function)
        ;; (diminish 'visual-line-mode)
        ;; (diminish 'global-visual-line-mode)
        (after 'autopair  (diminish 'autopair-mode))
        (after 'abbrev    (diminish 'abbrev-mode))
        (after 'undo-tree (diminish 'undo-tree-mode))
        (after 'org-indent (diminish 'org-indent-mode))
        (after 'magit (diminish 'magit-auto-revert-mode))
        (after 'fic-mode (diminish 'fic-mode))
        (after 'eldoc (diminish 'eldoc-mode))
        (after 'smerge-mode (diminish 'smerge-mode))
        (after 'auto-complete (diminish 'auto-complete-mode))
        (after 'esc-mode (diminish 'esc-mode))))

  (add-hook 'esc-mode-hook 'esc/accompanying-mode-hook)
#+END_SRC
*** esc fin
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (esc-mode 1)
  (provide 'esc-mode)
#+END_SRC

** multiple-cursors-config
Configuration for [[https://github.com/magnars/multiple-cursors.el][magnars/multiple-cursors.el · GitHub]].
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/multiple-cursors-config.el
(defcustom esc/multiple-cursors-mode-enabled-hook nil
  "esc's code to \\[multiple-cursors-mode-enabled-hook]."
  :type         'hook
  :options      '((autopair-mode -1)
		  (define-key mc/keymap (kbd "C-s") 'mc/search-forward)
		  (define-key mc/keymap (kbd "C-r") 'mc/search-backward))
  :group        'multiple-cursors)

;;;###autoload
(defun esc/multiple-cursors-mode-enabled-hook ()
  "esc's code to \\[multiple-cursors-mode-enabled-hook]."
  (autopair-mode -1)
  ;; mc/keymap isn't created until this point
  (defvar mc/search--last-term nil)
  (define-key mc/keymap (kbd "C-s") 'mc/search-forward)
  (define-key mc/keymap (kbd "C-r") 'mc/search-backward))

(defcustom esc/multiple-cursors-mode-disabled-hook nil
  "esc's code to \\[multiple-cursors-mode-disabled-hook]."
  :type         'hook
  :options      '((autopair-mode 1))
  :group        'multiple-cursors)

;;;###autoload
(defun esc/multiple-cursors-mode-disabled-hook ()
  "esc's code to \\[multiple-cursors-mode-disabled-hook]."
  (autopair-mode 1))

#+END_SRC

Thanks, Jeff Chu! [[http://www.jeffchu.com/posts/2013/01/2013-01-29-multiple-cursors-mode.html][
Jeff Chu - Emacs Multiple Cursors Mode and Search]]
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/multiple-cursors-config.el
;;;###autoload
(defun mc/search (search-command)
  "Iterate through each active cursor and search for the designated string.
SEARCH-COMMAND is the command to use for movement- either
\\[search-forward] or \\[search-backward].

Helper defun for \\[mc/search-forward] and \\[mc/search-backward]."
  ;; Read new search term when not repeated command or applying to fake cursors
  (when (and (not mc--executing-command-for-fake-cursor)
             (not (eq last-command 'mc/search-forward))
             (not (eq last-command 'mc/search-backward)))
    (setq mc/search--last-term (read-from-minibuffer "Search: ")))
  (funcall search-command mc/search--last-term))

;;;###autoload
(defun mc/search-forward ()
  "Simplified version of forward search that supports multiple cursors."
  (interactive)
  (mc/search 'search-forward))

;;;###autoload
(defun mc/search-backward ()
  "Simplified version of backward search that supports multiple cursors."
  (interactive)
  (mc/search 'search-backward))
#+END_SRC

*** [0/1] TODOs
**** TODO allow for regexp's in isearch

** scroll-all-config
As always, the [[http://www.emacswiki.org/emacs/ScrollAllMode][EmacsWiki]] is a magnificent resource.
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/scroll-all-config.el
  ;;;###autoload
  (defun mwheel-scroll-all-function-all (func arg)
    (if scroll-all-mode
        (save-selected-window
          (walk-windows
           (lambda (win)
             (select-window win)
             (condition-case nil
                 (funcall func arg)
               (error nil)))))
      (funcall func arg)))

  ;;;###autoload
  (defun mwheel-scroll-all-scroll-up-all (&optional arg)
    (mwheel-scroll-all-function-all 'scroll-up arg))

  ;;;###autoload
  (defun mwheel-scroll-all-scroll-down-all (&optional arg)
    (mwheel-scroll-all-function-all 'scroll-down arg))
#+END_SRC

** update-autoloads
*** Book of Autoload Spells
Incantation inspired by [[http://stackoverflow.com/questions/4189159/emacs23-elisp-how-to-properly-autoload-this-library/4189794#4189794][(where else?) Stack Overflow]].
#+NAME: variable declared with defcustom
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/update-autoloads.el
  ;;;###autoload
  (defgroup autoloads nil
    "Simplified maintenance of magic-cookie autoloads."
    :version "0.1.0")
#+END_SRC

#+NAME: recursively find .el files
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/update-autoloads.el
  ;;;###autoload
  (defun list-files-in-subtree-matching-regexp-recursive (directory &optional regexp)
    "List the `.el' files in DIRECTORY and in its sub-directories.

  If REGEXP is non-nil, compile a list of files matching REGEXP
  instead of `.el'."
    (interactive "Directory: ")
    (let (el-files-list
          (current-directory-list
           (directory-files-and-attributes directory t)))
      (let ((file-regexp (or regexp ".el")))
        ;; while we are in the current directory
        (while current-directory-list
          (cond
           ;; check to see whether filename ends in `.el'
           ;; and if so, append its name to a list.
           ((string-match file-regexp (car (car current-directory-list)))
            (setq el-files-list
                  (cons (car (car current-directory-list)) el-files-list)))
           ;; check whether filename is that of a directory
           ((eq t (car (cdr (car current-directory-list))))
            ;; decide whether to skip or recurse
            (if
                (equal "."
                       (substring (car (car current-directory-list)) -1))
                ;; then do nothing since filename is that of
                ;;   current directory or parent, "." or ".."
                ()
              ;; else descend into the directory and repeat the process
              (setq el-files-list
                    (append
                     (list-files-in-subtree-matching-regexp-recursive
                      (car (car current-directory-list)) file-regexp)
                     el-files-list)))))
          ;; move to the next filename in the list; this also
          ;; shortens the list so the while loop eventually comes to an end
          (setq current-directory-list (cdr current-directory-list)))
        el-files-list)))
#+END_SRC

#+NAME: find the nearest loaddefs.el file to pwd
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/update-autoloads.el
  ;;;###autoload
  (defun get-project-loaddefs-path (base)
    "Return the path to the closest loaddefs.el file relative to BASE.

  Only query this defun with BASE as a subdir of ~/.emacs.d/esc-lisp."
    (interactive)
    (catch 'found
      (let ((loaddefs "loaddefs.el")
            (base     (replace-regexp-in-string "/$" "" (expand-file-name base)))
            (top-dir  (expand-file-name "~/.emacs.d/site-lisp")))
        (unless (file-exists-p    base) (throw 'found nil))
        (unless (file-directory-p base)
          (setq base (replace-regexp-in-string
                      "/$" "" (file-name-directory base))))
        (while (string-match top-dir base) ;base is a subdir of home
          (when (member loaddefs (directory-files base))
            (throw 'found (concat base "/" loaddefs)))
          (setq base (file-name-directory ;remove trailing slash
                      (replace-regexp-in-string "/$" "" base)))))
      (throw 'found nil)))
#+END_SRC

#+NAME: Verse of autoload Black Magic
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/update-autoloads.el
  ;;;###autoload
  (defgroup autoloads nil
    "Simplified maintenance of magic-cookie autoloads."
    :version "0.1.0")

  ;;;###autoload
  (defun list-files-in-subtree-matching-regexp-recursive (directory &optional regexp)
    "List the `.el' files in DIRECTORY and in its sub-directories.

  If REGEXP is non-nil, compile a list of files matching REGEXP
  instead of `.el'."
    (interactive "Directory: ")
    (let (el-files-list
          (current-directory-list
           (directory-files-and-attributes directory t)))
      (let ((file-regexp (or regexp ".el")))
        ;; while we are in the current directory
        (while current-directory-list
          (cond
           ;; check to see whether filename ends in `.el'
           ;; and if so, append its name to a list.
           ((string-match file-regexp (car (car current-directory-list)))
            (setq el-files-list
                  (cons (car (car current-directory-list)) el-files-list)))
           ;; check whether filename is that of a directory
           ((eq t (car (cdr (car current-directory-list))))
            ;; decide whether to skip or recurse
            (if
                (equal "."
                       (substring (car (car current-directory-list)) -1))
                ;; then do nothing since filename is that of
                ;;   current directory or parent, "." or ".."
                ()
              ;; else descend into the directory and repeat the process
              (setq el-files-list
                    (append
                     (list-files-in-subtree-matching-regexp-recursive
                      (car (car current-directory-list)) file-regexp)
                     el-files-list)))))
          ;; move to the next filename in the list; this also
          ;; shortens the list so the while loop eventually comes to an end
          (setq current-directory-list (cdr current-directory-list)))
        el-files-list)))

  ;;;###autoload
  (defun get-project-loaddefs-path (base)
    "Return the path to the closest loaddefs.el file relative to BASE.

  Only query this defun with BASE as a subdir of ~/.emacs.d/site-lisp/esc-lisp."
    (interactive)
    (catch 'found
      (let ((loaddefs "loaddefs.el")
            (base     (replace-regexp-in-string "/$" "" (expand-file-name base)))
            (top-dir  (expand-file-name "~/.emacs.d/site-lisp/esc-lisp")))
        (unless (file-exists-p    base) (throw 'found nil))
        (unless (file-directory-p base)
          (setq base (replace-regexp-in-string
                      "/$" "" (file-name-directory base))))
        (while (string-match top-dir base) ;base is a subdir of home
          (when (member loaddefs (directory-files base))
            (throw 'found (concat base "/" loaddefs)))
          (setq base (file-name-directory ;remove trailing slash
                      (replace-regexp-in-string "/$" "" base)))))
      (throw 'found nil)))

  ;;;###autoload
  (defun update-esc-lisp-autoloads (&optional base)
    "Update autoload definitions for Lisp files in the directories DIRS.
  In an interactive call, you must give one argument, the name of a
  single directory.  In a call from Lisp, you can supply multiple
  directories as separate arguments, but this usage is discouraged.

  The function DOES recursively descend into subdirectories of the
  directory or directories specified.

  Note: this docstring was copied from \\[update-directory-autoloads]."
    (interactive
     (let ((file buffer-file-name))
       (list
        (read-file-name "Update autoloads (recursively) in which dir: "
                        esc-lisp-path esc-lisp-path))))
    (unless base (setq base esc-lisp-path))
    (setq base (replace-regexp-in-string "/$" "" (expand-file-name base)))
    (let ((el-files (list-files-in-subtree-matching-regexp-recursive
                     (expand-file-name base))))
      (dolist (el el-files)
        (ignore-errors
          (unless (string-match "loaddefs.el" el)
            (message (format "%s" el))
            (update-file-autoloads el t (get-project-loaddefs-path el)))))
      (message (concat "Generating autoloads for " base "...done"))))

  (provide 'update-autoloads)
#+END_SRC

* [12/29] TODOs
** DONE make_tags
make an emacs wrapper to ido-select a dir and tagsgen from there
** DONE fix load path
** DONE quick dictionary
** DONE remove tangles files from git, provide makefile
** DONE allow tabs in makefile-mode
  works with tabify
** DONE byte-compile-directory
** DONE diminish stuff
** DONE smooth esc scrolling
  best definition so far: scrolling that increases over time
** DONE naming standard for org babel files sectioning
** DONE use package use-package
** TODO publish esc-mode on melpa
** TODO scratch buffer as consistent config file
  only emacs-lisp source blocks from the org file are loaded,
  naturally
** TODO gcov output parsed by emacs to hilight gdb code coverage
** TODO Help+ standardization
you have C-h C-M-c, make C-h C-M-k! and f, etc
** TODO recentf
- prefer org over el and txt like ido
** TODO /meta
move recentf, other meta files into meta
** TODO minibufer
- [ ] disable M-n hydra
** [0/1] general purpose deuns
- [ ] follow mode 80 char compliant
  to its own mode
- [ ] kill buffer and reopen file
  when revert-buffer just doesn't cut it
** [1/3] make process
*** TODO generate loaddefs
*** HACKED ensure dir structure is populated in esc-lisp before attempted make
xo*** TODO asynchronous tangling
** [1/2] Powerline
*** DONE make powerline part of esc-mode
*** TODO activate =size-indication-mode= with =power-line-mode=
[[https://github.com/otijhuis/emacs/tree/master/vendor/powerline][emacs/vendor/powerline at master · otijhuis/emacs · GitHub]]
** [0/1] Dired
*** TODO human readable sizes in dired
  First have to determine how to unhide information on demand
  for definitions, not spell check
** [0/5] advice
*** TODO tangling scripts adds execute permission
  (write-region "" nil custom-file)
*** TODO finding tags
look in dirs above for TAGS file and suggest it
*** TODO org C-c ' to preserve window configuration?
*** TODO C-h C-k takes you to org instead of .el
*** TODO C-x M-r to save undo information
** [0/2] backburner
*** [0/2] ibuffer-vc
On the backburner because I haven't used ibuffer in some time.
**** TODO create mode to replace sort-by -mode with -ssh host
**** TODO make it group files over tramp
