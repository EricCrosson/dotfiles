#+author: Eric Crosson
#+email: esc@ericcrosson.com
#+todo: TODO(t) VERIFY(v) IN-PROGRESS(p) PRINT(r) | OPTIONAL(o) HIATUS(h) DONE(d) DISCARDED(c)
#+startup: content
* Introduction
#+BEGIN_SRC emacs-lisp :tangle yes
    ;;; .emacs.el

    ;;; Commentary:
    ;;; This is the .emacs file written and used by esc. The .el file is
    ;;; not the original form of this document; it was written in org
    ;;; babel. If you are not viewing the org document, you should try to
    ;;; locate it. It's much nicer to humans.

    ;;; License:
    ;;; esc's .emacs configuration file, for a smoother Emacs experience.
    ;;; Copyright (C) 2013 Eric Crosson
    ;;;
    ;;; This program is free software: you can redistribute it and/or modify
    ;;; it under the terms of the GNU General Public License as published by
    ;;; the Free Software Foundation, either version 3 of the License, or
    ;;; (at your option) any later version.
    ;;;
    ;;; This program is distributed in the hope that it will be useful,
    ;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
    ;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    ;;; GNU General Public License for more details.
    ;;;
    ;;; You should have received a copy of the GNU General Public License
    ;;; along with this program. If not, see <http://www.gnu.org/licenses/>.

    ;;; Code:
#+END_SRC

* Load path
This is a neat trick I found to take away 99.9% of the headache when
dealing with Emacs' load path. Assuming the user has placed every
file, script and dependency in his or her =~/.emacs.d/= directory,
this block will ensure Emacs can find each file come load time. No
need to keep the list updated, just load all subdirectories and go.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom site-lisp-path nil
    "Path to esc's lisp library."
    :type 'path
    :options '("~/.emacs.d/site-lisp/")
    :group 'esc-mode)
  (setq site-lisp-path "~/.emacs.d/site-lisp/")

  (defcustom esc-lisp-path nil
    "Path to esc's lisp library."
    :type 'path
    :options '("~/.emacs.d/site-lisp/esc-lisp/")
    :group 'esc-mode)
  (setq esc-lisp-path (concat site-lisp-path "esc-lisp/"))

  (defcustom esc-loaddefs-path nil
    "Path to `loaddefs.el' file used by esc's Emacs sessions."
    :type 'path
    :options '("~/.emacs.d/site-lisp/esc-lisp/loaddefs.el")
    :group 'esc-mode)
  (setq esc-loaddefs-path (concat esc-lisp-path "loaddefs.el"))

  (let ((default-directory site-lisp-path))      ;for easy
    (normal-top-level-add-to-load-path '("."))   ;recursive
    (normal-top-level-add-subdirs-to-load-path)) ;loading

  (autoload 'list-files-in-subtree-matching-regexp-recursive
    (concat esc-lisp-path "update-autoloads/update-autoloads.el"))
  ;; Load all project's loaddefs.el (automatically managed)
  (mapc (lambda (loaddef) (load-file loaddef))
        (list-files-in-subtree-matching-regexp-recursive
         esc-lisp-path "loaddefs.el"))
#+END_SRC

Set up [[https://github.com/tarsius/auto-compile][auto-compile mode]] to compile source files before loading iff
source is newer than the presently compiled file. A good tradeoff
with proper distributed version control.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq load-prefer-newer t)
  (require 'auto-compile)
  (auto-compile-on-load-mode 1)
#+END_SRC

* UI
Now that the legal stuff is out of the way, let's get out the rat poison.
#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc (lambda (mode) (when (fboundp mode) (funcall mode -1)))
        '(menu-bar-mode
          tool-bar-mode
          scroll-bar-mode))
#+END_SRC

Fire up the mood lighting
#+BEGIN_SRC emacs-lisp :tangle yes
  (load-theme 'wombat)
  (mapcar (lambda (data) (set-face-attribute (car data) nil
                                        :underline  nil
                                        :foreground 'unspecified
                                        :background (cadr data)))
          '((highlight "#444")
            (region    "#666")))
#+END_SRC

[[http://2.media.bustedtees.cvcdn.com/e/-/bustedtees.09c737ee-d77b-45da-ac5c-b9bbb562.gif][Powerâš¡Line]]
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'powerline)
  (powerline-default-theme)
#+END_SRC
* Free variables
Free as in free of compiler warnings.
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-when-compile
    (defvar package-user-dir)
    (defvar package-archives)
    (defvar uniquify-separator)
    (defvar uniquify-buffer-name-style)
    (defvar save-place-file)
    (defvar display-time-load-average-threshold)
    (defvar dabbrev-case-replace)
    (defvar compilation-save-buffers-predicate)
    (defvar starttls-use-gnutls)
    (defvar recentf-auto-cleanup)
    (defvar c-default-style)
    (defvar c-basic-offset)
    (defvar ido-create-new-buffer)
    (defvar desktop-save)
    (defvar desktop-path)
    (defvar desktop-base-filename)
    (defvar desktop-load-locked-desktop)
    (defvar ff-always-in-other-window)
    (defvar ff-always-try-to-create)
    (defvar ff-search-directories)
    (defvar eshell-mode-map)
    (defvar eshell-where-to-jump)
    (defvar eshell-review-quick-commands)
    (defvar eshell-smart-space-goes-to-end)
    (defvar w3m-mode-map)
    (defvar iedit-mode-keymap)
    (defvar w32-pass-lwindow-to-system)
    (defvar w32-pass-rwindow-to-system)
    (defvar w32-pass-apps-to-system)
    (defvar w32-lwindow-modifier)
    (defvar w32-rwindow-modifier)
    (defvar w32-apps-modifier)
    (defvar mac-command-modifier)
    (defvar mac-option-modifier)
    (defvar ns-function-modifier)
    (defvar dired-mode-map)
    (defvar org-replace-disputed-keys)
    (defvar org-clock-persist)
    (defvar org-hide-leading-stars)
    (defvar org-hide-emphasis-markers)
    (defvar org-src-fontify-natively)
    (defvar org-agenda-files)
    (defvar org-confirm-babel-evaluate)
    (defvar display-time-24hr-format)
    (defvar global-auto-revert-non-file-buffers)
    (defvar auto-revert-verbose))
#+END_SRC

* Macros
I took the macro below from [[http://milkbox.net/note/single-file-master-emacs-configuration/][milkypostman]]. His article is really worth
a read; stop what you're doing and go take a look if you haven't.
#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro after (mode &rest body)
  "`eval-after-load' MODE evaluate BODY."
  (declare (indent defun))
  `(eval-after-load ,mode
     '(progn ,@body)))
#+END_SRC

A macro to wrap code execution in those handy =*Messages*= style
notifications.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro message-progress (message &rest body)
    "Message MESSAGE and run BODY. Then message MESSSAGE...done."
    (declare (indent defun))
    `(progn
       (message ,message)
       (progn ,@body)
       (message (concat ,message "...done"))))
#+END_SRC

Facilitate normal initialization processes.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro autoload-from-package (package functions)
    "From PACKAGE (string), autoload FUNCTIONS (list)."
    (declare (indent defun))
    `(mapc (lambda (fn) (autoload fn ,package nil t))
           ,functions))

  (defmacro require-package (packages)
    "Require PACKAGES (list) quietly."
    (declare (indent defun))
    `(mapc (lambda (package) (require package nil 'noerror))
           ,packages))
#+END_SRC

* Package configuration
#+NAME: package-manager-initialization
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (require 'package nil 'noerror)
    (setq package-user-dir (concat site-lisp-path "elpa/"))
    (mapc (lambda (source) (add-to-list 'package-archives source) t)
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("marmalade" . "http://marmalade-repo.org/packages/")
            ("melpa-stable" . "http://melpa-stable.milkbox.net/packages/")
            ("melpa" . "http://melpa.milkbox.net/packages/")))
    (package-initialize))
#+END_SRC

* User metadata
Hello, My Name Is
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq user-full-name "Eric Crosson"
        user-mail-address "esc@ericcrosson.com")
#+END_SRC

* Behavioral modifications
#+NAME: behavioral-modifications
#+BEGIN_SRC emacs-lisp :tangle yes
  (put 'overwrite-mode 'disabled t)       ;There shall be no 'insert'
  (fset 'yes-or-no-p 'y-or-n-p)           ;change yes-no to y-n
  (setq-default size-indication-mode t)
  (setq debug-on-error t
        inhibit-startup-screen t
        initial-scratch-message nil
        ring-bell-function 'ignore        ;turn off alarms completely
        disabled-command-function 'beep   ;alert me when accessing disabled funcs
        redisplay-dont-pause t            ;don't pause refreshes
        frame-title-format '("emacs@" system-name ": %f") ;include path of frame
        display-time-load-average-threshold 0.6
        dabbrev-case-replace nil
        display-buffer-reuse-frames t     ;raise buffers, not spawn
        remote-file-name-inhibit-cache t  ;don't resolve remote file attrubutes
        auto-save-default nil
        large-file-warning-threshold nil
        set-mark-command-repeat-pop t
        starttls-use-gnutls t
        browse-url-browser-function 'browse-web
        kill-buffer-query-functions (remq 'process-kill-buffer-query-function
                                           kill-buffer-query-functions))
#+END_SRC

Now everybody agrees that the =*Minibuffer*= is unreadable, right?
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq minibuffer-prompt-properties '(read-only t point-entered
                                                 minibuffer-avoid-prompt face
                                                 minibuffer-prompt))
#+END_SRC

Line numbers, when visible, should be loaded after a short delay and
not loaded eagerly. They're candy, and who spends resources acquiring
candy?
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq linum-delay t
        linum-eager nil)
#+END_SRC

These settings keep the text soup that is GNU/Linux as happy as
GNU/Linux files can be.
#+NAME: char-and-font-encoding
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Char and font encoding
  (set-buffer-file-coding-system 'unix)   ;Unix mode. Always
  (setq c-default-style "linux"
        c-basic-offset 2
        ido-create-new-buffer 'always
        require-final-newline 'visit-save ;compliance
        indent-tabs-mode nil
        comment-style 'indent)
#+END_SRC

It is my belief that backup files should not be so obtrusive as to
tempt users to disable them.
#+NAME: stash-backups
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Backup settings
  (push '("." . "~/.config/.emacs.d/") backup-directory-alist)
  (desktop-save-mode 1)                   ;use desktop file
  (setq desktop-save 'if-exists                 ;save open buffers
        desktop-path '("~/emacs.d")       ;local desktop files
        desktop-base-filename "desktop"
        desktop-load-locked-desktop t     ;never freeze after crash
        backup-by-copying-when-linked t
        backup-by-copying-when-mismatch t)
#+END_SRC

Keep a history of =M-x= across sessions.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq savehist-file (concat user-emacs-directory "meta/savehist"))
  (savehist-mode 1)
  (setq savehist-save-minibuffer-history 1)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))
#+END_SRC

* Aliases
I did not grow up in an era where this is a straightforward mnemonic.
#+NAME: alias fmakunbound => undefun
#+BEGIN_SRC emacs-lisp :tangle yes
  (defalias 'undefun 'fmakunbound)
#+END_SRC

* Advice
** org advice
Shrink the agenda buffer as small as we can and keep it that way
#+NAME: Shrink agenda buffer
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice org-agenda (around shrink-agenda-buffer activate)
    "Shrink the agenda after initial display."
    ad-do-it
    (shrink-window-if-larger-than-buffer))

  ;; keep it shrunken upon refresh
  (defadvice org-agenda-redo (around shrink-agenda-buffer-after-refresh activate)
    "Shrink the agenda after refreshing the display."
    ad-do-it
    (shrink-window-if-larger-than-buffer))
#+END_SRC

** advising built-in commands
The following macro is to prevent the user from manually having to
create directories (=M-x make-directory RET RET=) after using
=find-file= on a nonexistent file.
#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice find-file (before make-directory-maybe
			     (filename &optional wildcards) activate)
  "Create nonexistent parent directories while visiting files."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
    "Kill `term-mode' buffers when an exit signal is received."
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))
#+END_SRC

*** comment-dwim
I wrote a post about my path to this advice somewhere. I'll find a link when it's stable.
#+NAME: One Commenter to Rule Them All (TM)
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice comment-dwim (around comment-line-maybe activate)
    "If invoked from the beginning of a line or the beginning of
  text on a line, comment the current line instead of appending a
  comment to the line."
    (if (and (not (use-region-p))
             (not (eq (line-end-position)
                      (save-excursion (back-to-indentation) (point))))
             (or (eq (point) (line-beginning-position))
                 (eq (point) (save-excursion (back-to-indentation) (point)))))
        (comment-or-uncomment-region (line-beginning-position)
                                     (line-end-position))
      ad-do-it
      (setq deactivate-mark nil)))
#+END_SRC

Prefix '0' to comment-dwim to kill comments entirely.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice comment-dwim (around delete-comment-if-prefixed activate)
    "If the universal prefix to \\[comment-dwim] is 0, delete the
    comment from the current line or marked region."
    (if (not (eq current-prefix-arg 0))   ; normal behavior
        ad-do-it
      (let ((comments (if (region-active-p)
                          (count-lines (region-beginning) (region-end))
                        1)))
        (save-excursion
          (when (region-active-p)
            (goto-char (region-beginning)))
          (comment-kill comments)))))
#+END_SRC

TODO: write about how cool this is! (not related to above comment
about a post)

** undo tree advice
Make zipped files obvious.
#+BEGIN_SRC emacs-lisp :tangle no
  (after 'undo-tree
    (defadvice undo-tree-make-history-save-file-name
    (after undo-tree activate)
    (setq ad-return-value (concat ad-return-value ".gz"))))
#+END_SRC

* Package initialization
#+NAME: require-packages
#+BEGIN_SRC emacs-lisp :tangle yes
  (require-package
    '(cl-lib                               ;The Golden Package
      org                                  ;The Platinum Package
      saveplace                            ;included in gnuemacs
      uniquify                             ;included in gnuemacs
      midnight                             ;included in gnuemacs
      which-func                           ;included in gnuemacs
      eldoc                                ;included in gnuemacs
      auto-complete
      notifications
      dired-x
      pretty-lambdada
      vc-hooks

      ;; custom packages
      ; is there a way to get these autoloads loaded implicitly, like
      ; elpa does?
      esc-mode                             ;The Power Glove
      displaced-yank))
#+END_SRC

* Configuration
** Lua mode config
Lua: necessary for Awesome WM.
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'lua-mode-autoloads
    (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode)))
#+END_SRC

** Undo tree config
Thanks to [[http://whattheemacsd.com/my-misc.el-02.html][Magnar]] for the advice.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice undo-tree-undo (around keep-region activate)
    (if (use-region-p)
        (let ((m (set-marker (make-marker) (mark)))
              (p (set-marker (make-marker) (point))))
          ad-do-it
          (goto-char p)
          (set-mark m)
          (set-marker p nil)
          (set-marker m nil))
      ad-do-it))
#+END_SRC

** Spray config
This mode is based on openspritz, a speedreading tutor.
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "spray" '(spray-mode))
#+END_SRC

** Enhanced ruby mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload 'enh-ruby-mode "enh-ruby-mode" "Major mode for ruby files" t)
#+END_SRC

** ibuffer config
Modify ibuffer view to include human readable size information.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Use human readable Size column instead of original one
  (after 'ibuffer
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 100000)  (format "%7.0fk" (/ (buffer-size) 1000.0)))
       ((> (buffer-size) 1000)    (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))

    (setq ibuffer-formats
          '((mark modified read-only         " "
                  (name 18 18  :left :elide) " "
                  (size-h 9 -1 :right)       " "
                  (mode 16 16  :left :elide) " "
                  filename-and-process))))
#+END_SRC

*** elpa packages
ibuffer-vc is great; make it automatic.
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'ibuffer-vc-autoloads
    (defun esc/ibuffer-vc-refresh ()
      (ibuffer-vc-set-filter-groups-by-vc-root)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    (add-hook 'ibuffer-hook 'esc/ibuffer-vc-refresh))
#+END_SRC

Include vc status info in the buffer list.
Mabye I'll include this one day, for now it can live in hibernation.
#+BEGIN_SRC emacs-lisp :tangle no
  (after 'ibuffer-vc-autoloads
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 18 18 :left :elide)         " "
                  (size 9 -1  :right)               " "
                  (mode 16 16 :left :elide)         " "
                  (vc-status 16 16 :left)           " "
                  filename-and-process))))
#+END_SRC

** Minimap config
  #+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "minimap"
    '(minimap-kill
      minimap-create
      minimap-mode))
#+END_SRC

** Tea-time config
#+BEGIN_SRC emacs-lisp :tangle no
  (autoload-from-package "tea-time" '(tea-time))
#+END_SRC

** Scroll all mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mwheel-scroll-up-function   'mwheel-scroll-all-scroll-up-all
        mwheel-scroll-down-function 'mwheel-scroll-all-scroll-down-all)
#+END_SRC

** Very Large File mode config
Configure options for transparent handling of very large files.
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'vlf-integrate
    (vlf-set-batch-size (* 10 1024))    ;1.mb
    (custom-set-variables
     '(vlf-application 'dont-ask)))
#+END_SRC
** Conf mode config
#+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list
     'auto-mode-alist
     '("\\.\\(screenrc\\)\\'" . conf-mode))
#+END_SRC
** Web mode config
TODO: disable autopair-mode for web-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.jsp$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
#+END_SRC

** C config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ff-search-directories '("." "../inc" "../src"))
  (add-to-list 'auto-mode-alist '("\\.tcc$" . c++-mode))
  (setq c-eldoc-includes "`pkg-config gtk+-2.0 --cflags` -I./ -I../ ")
#+END_SRC
** Ruby mode config
Verbatim from the [[http://www.emacswiki.org/emacs/RubyMode][emacswiki]].
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.rb$" . enh-ruby-mode))
  (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
  (add-to-list
   'auto-mode-alist
   '("\\.\\(?:gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'"
     . enh-ruby-mode))
  (add-hook 'enh-ruby-mode-hook 'esc/enh-ruby-mode-hook)
#+END_SRC

** FIC-mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook 'turn-on-fic-mode)
#+END_SRC
** Saveplace config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq save-place-file (expand-file-name "meta/places" user-emacs-directory))
  (after 'saveplace
      (setq save-place-file (concat user-emacs-directory "meta/saveplace.el"))
      (setq-default save-place t))
#+END_SRC

** Xorg yank config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq x-select-enable-clipboard t       ;global clipboard
        mouse-yank-at-point t)
#+END_SRC
** Compilation config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq compile-command "make -k -j32"
          compilation-ask-about-save nil
          compilation-save-buffers-predicate '(lambda () nil)) ;never ask to save
#+END_SRC

** Byte compilation config
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Diminish compiler warnings
  (setq byte-compile-warnings '(not interactive-only free-vars))
  (add-hook 'after-save-hook 'esc/auto-byte-recompile)
#+END_SRC

** Recentf config
#+NAME: recentf configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq recentf-auto-cleanup 'never)  ;must be set before recentf loaded
  (after 'recentf
    (setq recentf-max-menu-items 25
          recentf-max-saved-items 25
          recentf-keep '(file-remote-p file-readable-p)))
#+END_SRC

** Tea-time config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'notifications
    (defun esc/notify-tea-steeped ()
      (notifications-notify :title "Tea time"
                            :body "Rip out that sac, because your tea bag is done"
                            :app-name "Tea Time"
                            :sound-name "alarm-clock-elapsed"))
    (add-hook 'tea-time-notification-hook 'esc/notify-tea-steeped))
#+END_SRC
** LaTeX config
Sounded like a good idea thanks to [[http://orgmode.org/worg/org-tutorials/org-latex-export.html][orgmode.com]].
#+NAME: LaTeX configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'latex-mode
    ;; (add-to-list 'org-export-latex-classes
    ;;           '("article"
    ;;             "\\documentclass{article}"
    ;;             ("\\section{%s}" . "\\section*{%s}")
    ;;             ("\\subsection{%s}" . "\\subsection*{%s}")
    ;;             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
    ;;             ("\\paragraph{%s}" . "\\paragraph*{%s}")
    ;;             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    (load "auctex.el" nil t t)
    (load "preview-latex.el" nil t t)
    (setq TeX-command-default "latex"
          TeX-auto-save t
          TeX-parse-self t
          TeX-PDF-mode t
          latex-run-command "pdflatex")
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (local-set-key (kbd "C-c C-s") 'latex-math-preview-expression))
  ;; (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC

** Flyspell mode config
#+NAME: Flyspell mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'flyspell-mode
    (setq flyspell-issue-message-flag nil))
#+END_SRC

** Doc view mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'doc-view-mode
    (setq doc-view-continuous t))
#+END_SRC

** Auto-complete mode config
#+NAME: auto-complete mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'auto-complete-mode
    (ac-config-default)
    (add-to-list 'ac-dictionary-directories
                 "~/.emacs.d/auto-complete/ac-dict"))
#+END_SRC

** Abbrev mode config
#+NAME: abbrev-mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'abbrev-mode
    (setq abbrev-file-name "~/emacs.d/abbrev.lst"
          save-abbrevs t)
    (if (file-exists-p abbrev-file-name) ;load custom abbrevs
        (quietly-read-abbrev-file)))
#+END_SRC

** Idle highlight config
#+NAME: idle highlight configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'idle-highlight
    (setq-default idle-highlight-idle-time 10.0))
#+END_SRC
** Uniquify config
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; needs to be set before uniquify is loaded
  (setq uniquify-separator ":"
        uniquify-buffer-name-style 'post-forward)
#+END_SRC
** Ido config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'ido
    (setq ido-everywhere t                             ;always Ido
          ido-enable-flex-matching t                   ;smarter Ido
          ido-create-new-buffer 'always                ;quieter Ido
          ido-file-extensions-order '(".org" ".txt"))) ;precedence

  (autoload-from-package "ido-extras"
    '(ido-recentf-open
      ido-goto-symbol))
#+END_SRC

** Git gutter+ config
#+BEGIN_SRC emacs-lisp :tangle yes
  ;(global-git-gutter+-mode t)
  (after 'git-gutter+
    ;;; Jump between hunks
    (define-key git-gutter+-mode-map (kbd "C-x n") 'git-gutter+-next-hunk)
    (define-key git-gutter+-mode-map (kbd "C-x p") 'git-gutter+-previous-hunk)
     ;;; Act on hunks
    (define-key git-gutter+-mode-map (kbd "C-x v =") 'git-gutter+-show-hunk)
    ;; Stage hunk at point.
    ;; If region is active, stage all hunk lines within the region.
    (define-key git-gutter+-mode-map (kbd "C-x s") 'git-gutter+-stage-hunks)
    (define-key git-gutter+-mode-map (kbd "C-x c") 'git-gutter+-commit)
    (define-key git-gutter+-mode-map (kbd "C-x C") 'git-gutter+-stage-and-commit))
#+END_SRC

** Multiple cursors config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'multiple-cursors-autoloads
    (setq mc/list-file "~/.emacs.d/meta/.mc-lists.el"))
#+END_SRC
** Ace config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'ace-jump-mode (ace-jump-mode-enable-mark-sync))
  (after 'ace-window (setq aw-keys '(?a ?b ?c ?d ?e ?f ?g ?h ?i)))
#+END_SRC

** Which func config
#+NAME: which-func configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'which-func
    (mapc (lambda (mode) (add-to-list 'which-func-modes mode))
          '(org-mode
            emacs-lisp-mode
            c-mode
            c++-mode
            java-mode
            ruby-mode
            enh-ruby-mode)))
#+END_SRC

** Midnight mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'midnight                        ;clean stale buffers
    (midnight-delay-set 'midnight-delay "5:00am"))
    #+END_SRC

** Keyfreq mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'keyfreq                               ;let's take some stats
    (keyfreq-autosave-mode 1)
    ;; TODO; use var for meta dir
    (setq keyfreq-file "~/.emacs.d/meta/keyfreq"))
#+END_SRC

** Browse kill ring config
#+NAME: browse-kill-ring configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq kill-ring-max 80)
  (after 'browse-kill-ring
    (browse-kill-ring-default-keybindings))
#+END_SRC

** Mouse avoidance config
#+BEGIN_SRC emacs-lisp :tangle yes
  (mouse-avoidance-mode 'exile)
#+END_SRC

** Bitly config
#+NAME: bitly oauth token
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'bitly
    (setq bitly-access-token "b4a5cd4e51df442ab97012cfc2764c599d6eabf8"))
#+END_SRC
** Paradox config
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq paradox-github-token "37204ef66b6566274616d130ec61a0cd4f98e066")
#+END_SRC

** Autoloads
#+NAME: Miscellaneous autoloads
    #+BEGIN_SRC emacs-lisp :tangle yes
      (autoload-from-package "iedit"         '(iedit)) ;multi-replace
      (autoload-from-package "magit"         '(magit-status))
      (autoload-from-package "misc"          '(zap-up-to-char))
      (autoload-from-package "misc-cmds"     '(revert-buffer-no-confirm))
      (autoload-from-package "expand-region" '(er/expand-region))
      (autoload-from-package "autopair"      '(autopair-global-mode)) ;autopair characters
      (autoload-from-package "auto-complete" '(global-auto-complete-mode)) ;autocomplete syntax
    #+END_SRC

* Hooks
Attach =esc-mode= hooks
#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc (lambda (hook)
          (let ((attach (intern (format "esc/%s" hook))))
            (add-hook hook attach)))
        '(erc-mode-hook
          prog-mode-hook
          fundamental-mode-hook
          emacs-lisp-mode-hook
          c-mode-common-hook
          c++-mode-hook
          eshell-mode-hook
          iedit-mode-hook
          comint-mode-hook
          big-fringe-mode-hook
          org-mode-hook
          minibuffer-setup-hook
          dired-mode-hook
          dired-load-hook
          multiple-cursors-mode-enabled-hook
          multiple-cursors-mode-disabled-hook))
#+END_SRC

** Text mode hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
** Find-file hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'find-file-hook 'esc/remove-dos-eol)
#+END_SRC
** Lexbind mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'lexbind-mode
    (add-hook 'emacs-lisp-mode-hook 'lexbind-mode))
#+END_SRC

** Eshell hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'eshell-named-command-hook 'esc/eshell-exec-perl)
#+END_SRC

** Save hooks
Handy little hooks to nudge new files in the right direction.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Compilation buffer hook
#+NAME: Burying the Compilation buffer if successful
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'compilation-finish-functions
            'esc/bury-compilation-buffer-if-successful)
  (add-to-list 'same-window-buffer-names "*compilation*")
#+END_SRC
** Haskell mode hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'haskell-mode-hook 'haskell-indent-mode)
#+END_SRC
** Pretty lambdada mode hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc (lambda (prettify-this-mode)
          (add-hook prettify-this-mode 'pretty-lambda))
        '(emacs-lisp-mode-hook
          org-mode-hook ;to include source blocks :\
          enh-ruby-mode-hook
          ruby-mode-hook))
#+END_SRC
** Change major mode hook
Take this opportunity to refresh the mode line. Inspiration from
[[http://www.masteringemacs.org/article/hiding-replacing-modeline-strings][Hiding and replacing modeline strings with clean-mode-line - Mastering
Emacs]].
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'after-change-major-mode-hook 'clean-mode-line)
#+END_SRC
** Kill buffer hook
[[http://emacswiki.org/emacs/RecreateScratchBuffer][EmacsWiki: Recreate Scratch Buffer]]
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'kill-buffer-query-functions 'esc/unkillable-scratch-buffer)
#+END_SRC

** Kill emacs hook
Summon the magical cookies.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'kill-emacs-hook 'update-esc-lisp-autoloads)
#+END_SRC

Override the kill function.
#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'save-buffers-kill-emacs 'esc/save-buffers-kill-emacs)
#+END_SRC

* OS configuration
Operating system-specific configurations take place here, within this
massive =cond=.
#+NAME: Operating System specific configurations
#+BEGIN_SRC emacs-lisp :tangle yes
  (cond ((or (eq system-type 'ms-dos)
             (eq system-type 'windows-nt)
             (eq system-type 'cygwin))

         ;; Windows config
         (message-progress "Loading Windows specific configuration..."
           (setq w32-pass-lwindow-to-system nil
                 w32-pass-rwindow-to-system nil
                 w32-pass-apps-to-system nil
                 w32-lwindow-modifier 'super ; Left Windows key
                 w32-rwindow-modifier 'super ; Right Windows key
                 w32-apps-modifier 'hyper)   ; Menu key
           (require-package '(w32-symlinks))
#+END_SRC

Note: for GNU Emacs compiled for Microsoft, both of the below options
need to be set in order to follow symlinks. The shell snippet tells
cygwin to create symlinks in a friendly format (old links need to be
regenerated with this flag) and the sexp is loaded by Emacs allowing
transparent use of symlinks.

#+BEGIN_SRC sh :tangle no
  # TODO: tangle me
  export CYGWIN="nodosfilewarning winsymlinks"
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (customize-option 'w32-symlinks-handle-shortcuts)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
           ))
#+END_SRC

Begin Mac OS configuration

#+BEGIN_SRC emacs-lisp :tangle yes
         ((or (eq system-type 'darwin))
          (message-progress "Loading Darwin specific configuration..."
            (setq mac-command-modifier 'meta)
            (setq mac-option-modifier 'super)
            (setq ns-function-modifier 'hyper))))
#+END_SRC

* Dired configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (require-package '(dired-details))
  (dired-details-install)

  ;; auto-dired-reload
  ;; Reload dired after making changes
  (after 'dash
    (put '--each 'lisp-indent-function 1)
    (--each '(dired-do-rename
              dired-create-directory
              wdired-abort-changes)
            (eval `(defadvice ,it (after revert-buffer activate)
                     (revert-buffer)))))
#+END_SRC

** Wdired
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-after-load "wdired"
    '(progn
       (define-key wdired-mode-map (kbd "C-a") 'esc/dired-back-to-start-of-files)
       (define-key wdired-mode-map
         (vector 'remap 'beginning-of-buffer) 'esc/dired-back-to-top)
       (define-key wdired-mode-map
         (vector 'remap 'end-of-buffer) 'esc/dired-jump-to-bottom)))
#+END_SRC

* Colors
- [ ] TODO: load this with color-stack
Initialize the color-theme-stack
#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar color-theme-stack nil "Stack of color themes.")
#+END_SRC

Lay the color-theme-stack api
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/color-theme-stack.el
  ;;;###autoload
  (defun color-theme-push ()
    "Switch to a theme, saving the old one."
    (push (color-theme-make-snapshot) color-theme-stack)
    (message "Color theme pushed"))

  ;;;###autoload
  (defun color-theme-pop ()
    "Restore the previous theme in use."
    (funcall (pop color-theme-stack))
    (message "Color theme popped"))
#+END_SRC

* Organize mode configuration
** org advice
[[http://emacs.stackexchange.com/a/9347][org mode - How does one use flyspell in org buffers without flyspell
triggeri...]]

As of <2015-02-18 Wed> this advice did not work for me.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; NO spell check for embedded snippets
  (defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
    (let ((rlt ad-return-value)
          (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\)")
          (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\)")
          old-flag
          b e)
      (when ad-return-value
        (save-excursion
          (setq old-flag case-fold-search)
          (setq case-fold-search t)
          (setq b (re-search-backward begin-regexp nil t))
          (if b (setq e (re-search-forward end-regexp nil t)))
          (setq case-fold-search old-flag))
        (if (and b e (< (point) e)) (setq rlt nil)))
      (setq ad-return-value rlt)))
#+END_SRC

** org config
My favorite mode. This was the reason I started using Emacs, didja know?
#+NAME: org mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'org-modules 'org-habit)
  (setq-default major-mode 'org-mode)  ;default mode for new buffers
  (setq org-replace-disputed-keys t    ;must be set before org is loaded
        org-clock-persist 'history
        org-hide-leading-stars t
        org-hide-emphasis-markers t
        org-hierarchical-todo-statistics     nil
        org-checkbox-hierarchical-statistics nil
        org-habit-graph-column 55
        org-src-fontify-natively t
        org-directory "~/org"
        org-agenda-files (append '("~/workspace/ee445m-labs/doc/todo.org"
                                   "~/org/intel.org"
                                   "~/org/todo.org")))
#+END_SRC

[[http://lists.gnu.org/archive/html/emacs-orgmode/2012-05/msg00708.html][More information on defining your own Easy Templates]].
#+BEGIN_SRC emacs-lisp :tangle yes
    (after 'org
           (add-to-list 'org-structure-template-alist
                        '("E"
                          "#+BEGIN_SRC emacs-lisp ?\n\n#+END_SRC"
                          "<emacs-lisp>\n?\n</emacs-lisp>")))

#+END_SRC

** org babel
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'org-mode-hook
            (lambda ()
              (setq org-confirm-babel-evaluate nil)

              (org-babel-do-load-languages
               'org-babel-load-languages
               '(;; Always execute these languages
                 (R               .       t)
                 (ditaa           .       t)
                 (dot             .       t)
                 (plantuml        .       t)
                 (emacs-lisp      .       t)
                 (lisp            .       t)
                 (clojure         .       t)
                 (scala           .       t)
                 (gnuplot         .       t)
                 (haskell         .       t)
                 (ocaml           .       t)
                 (python          .       t)
                 (ruby            .       t)
                 (sh              .       t)
                 (sqlite          .       t)
                 (octave          .       t)
                 (plantuml        .       t)
                 ;; Never execute these languages
                 (screen          .       nil)
                 (sql             .       nil)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; org-export-blocks-format-plantuml.el Export UML using plantuml
  ;;
  ;; OBSOLETED, use ob-plantuml.el bundled in org instead.
  ;;
  ;; Copy from org-export-blocks-format-ditaa
  ;;
  ;; E.g.
  ;; #+BEGIN_UML
  ;;   Alice -> Bob: Authentication Request
  ;;   Bob --> Alice: Authentication Response
  ;; #+END_UML

  (eval-after-load "org-exp-blocks"
    '(progn
       (add-to-list 'org-export-blocks '(uml iy/org-export-blocks-format-plantuml nil))
       (add-to-list 'org-protecting-blocks "uml")))

  (defvar iy/org-plantuml-jar-path (expand-file-name "~/Dropbox/java-libs/plantuml.jar")
    "Path to the plantuml jar executable.")
  (defun iy/org-export-blocks-format-plantuml (body &rest headers)
    "Pass block BODY to the plantuml utility creating an image.
    Specify the path at which the image should be saved as the first
    element of headers, any additional elements of headers will be
    passed to the plantuml utility as command line arguments."
    (message "plantuml-formatting...")
    (let* ((args (if (cdr headers) (mapconcat 'identity (cdr headers) " ")))
           (data-file (make-temp-file "org-plantuml"))
           (hash (progn
                   (set-text-properties 0 (length body) nil body)
                   (sha1 (prin1-to-string (list body args)))))
           (raw-out-file (if headers (car headers)))
           (out-file-parts (if (string-match "\\(.+\\)\\.\\([^\\.]+\\)$" raw-out-file)
                               (cons (match-string 1 raw-out-file)
                                     (match-string 2 raw-out-file))
                             (cons raw-out-file "png")))
           (out-file (concat (car out-file-parts) "_" hash "." (cdr out-file-parts))))
      (unless (file-exists-p iy/org-plantuml-jar-path)
        (error (format "Could not find plantuml.jar at %s" iy/org-plantuml-jar-path)))
      (setq body (if (string-match "^\\([^:\\|:[^ ]\\)" body)
                     body
                   (mapconcat (lambda (x) (substring x (if (> (length x) 1) 2 1)))
                              (org-split-string body "\n")
                              "\n")))
      (cond
       ((or htmlp latexp docbookp)
        (unless (file-exists-p out-file)
          (mapc ;; remove old hashed versions of this file
           (lambda (file)
             (when (and (string-match (concat (regexp-quote (car out-file-parts))
                                              "_\\([[:alnum:]]+\\)\\."
                                              (regexp-quote (cdr out-file-parts)))
                                      file)
                        (= (length (match-string 1 out-file)) 40))
               (delete-file (expand-file-name file
                                              (file-name-directory out-file)))))
           (directory-files (or (file-name-directory out-file)
                                default-directory)))
          (with-temp-file data-file (insert (concat "@startuml\n" body "\n@enduml")))
          (message (concat "java -jar " iy/org-plantuml-jar-path " -pipe " args))
          (with-temp-buffer
            (call-process-shell-command
             (concat "java -jar " iy/org-plantuml-jar-path " -pipe " args)
             data-file
             '(t nil))
            (write-region nil nil out-file)))
        (format "\n[[file:%s]]\n" out-file))
       (t (concat
           "\n#+BEGIN_EXAMPLE\n"
           body (if (string-match "\n$" body) "" "\n")
           "#+END_EXAMPLE\n")))))

#+END_SRC

#+NAME: org latex export syntax highlighting
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Include the latex-exporter
  (require-package '(ox-latex))
  ;; Add minted to the defaults packages to include when exporting.
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  ;; Tell the latex export to use the minted package for source
  ;; code coloration.
  (setq org-latex-listings 'minted)
  ;; Let the exporter use the -shell-escape option to let latex
  ;; execute external programs.
  ;; This obviously and can be dangerous to activate!
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

** org beamer
Thanks to [[http://emacs-fu.blogspot.com/2009/10/writing-presentations-with-org-mode-and.html][emacs-fu]]!
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; allow for export=>beamer by placing
  ;; #+LaTeX_CLASS: beamer in org files
  (unless (boundp 'org-export-latex-classes)
    (setq org-export-latex-classes nil))
  (add-to-list 'org-export-latex-classes
    ;; beamer class, for presentations
    '("beamer"
       "\\documentclass[11pt]{beamer}\n
        \\mode<{{{beamermode}}}>\n
        \\usetheme{{{{beamertheme}}}}\n
        \\usecolortheme{{{{beamercolortheme}}}}\n
        \\beamertemplateballitem\n
        \\setbeameroption{show notes}
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{hyperref}\n
        \\usepackage{color}
        \\usepackage{listings}
        \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
    frame=single,
    basicstyle=\\small,
    showspaces=false,showstringspaces=false,
    showtabs=false,
    keywordstyle=\\color{blue}\\bfseries,
    commentstyle=\\color{red},
    }\n
        \\usepackage{verbatim}\n
        \\institute{{{{beamerinstitute}}}}\n
         \\subject{{{{beamersubject}}}}\n"

       ("\\section{%s}" . "\\section*{%s}")

       ("\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}"
         "\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}")))

    ;; letter class, for formal letters

    (add-to-list 'org-export-latex-classes

    '("letter"
       "\\documentclass[11pt]{letter}\n
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{color}"

       ("\\section{%s}" . "\\section*{%s}")
       ("\\subsection{%s}" . "\\subsection*{%s}")
       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
       ("\\paragraph{%s}" . "\\paragraph*{%s}")
       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

#+END_SRC
** org capture
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-default-notes-file (concat org-directory "/capture.org"))
  (after 'org
    (after 'esc-mode
      (esc-key "C-c C-p" 'org-capture)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-capture-templates
        '(;; General tasks go here
          ("t" "Todo" entry
           (file+headline (concat org-directory "/todo.org") "Tasks")
           "* TODO %?\n  %a")
          ;; Used to record my state
          ("j" "Journal" entry
           (file+datetree (concat org-directory "/journal.org"))
           "* %?\nEntered on %U\n  %i\n  %a")

          ;;; Work-related captures
          ("c" "Centaur" entry
           (file+datetree (concat org-directory "/centtech/centtech.org"))
           "* TODO %?\n  %i\n  %a")

          ;;; Personal captures
          ;; Notes about Super Smash Bros. 64
          ("s" "Smash Bros." entry
           (file+headline (concat org-directory "/smash/smash.org") "Notes")
           "* %?\n")))
#+END_SRC

*** org refile
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ;; Work refile locations
   esc-refile-targets-centtech
   `(,(concat org-directory "/centtech/lru.org")
     ,(concat org-directory "/centtech/pse.org")
     ,(concat org-directory "/centtech/newreg.org"))

   ;; Personal refile locations
   esc-refile-targets-smash
   `(,(concat org-directory "/smash/64.org")
     ,(concat org-directory "/smash/melee.org")
     ,(concat org-directory "/smash/pm.org"))

   org-refile-targets '((nil                         :maxlevel . 5)
                        (esc-refile-targets-centtech :maxlevel . 5)
                        (esc-refile-targets-smash    :maxlevel . 5)
                        (org-agenda-files            :maxlevel . 4)))
#+END_SRC

* Personal key-binding mode
** summary
Here lies my personal minor mode, where I confine all of my custom
keybindings. I also hook all of my preferred major and minor modes
onto this mode's activation hook. Though all of my customizations are
active by default for new emacs sessions, one can get back to the
default settings by running =M-x esc-mode=.

TODO: consider using `define-globalized-minor-mode'.

** esc variables

As a convention, esc functions are prefixed with `esc/' while esc
variables are prefixed with `esc-'

#+NAME: define customizable variables
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defcustom esc-line-shift-amount 6
      "The number of lines to shift in `esc-mode-map'."
      :type    'integer
      :options '(5 6)
      :group   'esc-mode)

  (defcustom esc-zoom-amount 10
      "The number of points to zoom in `esc-zoom-in' and `esc-zoom-out'."
      :type    'integer
      :options '(10)
      :group   'esc-mode)

  (defvar esc-mode-map (make-keymap)
      "The keymap for `esc-mode'.")

  ;;;###autoload
  (define-minor-mode esc-mode
      "Toggle esc-keys mode.
                   A minor mode so that my key settings override annoying major modes."
      t " esc" 'esc-mode-map)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  ;; TODO: devise method of keeping these options in sync with the
  ;; entire current implementation of esc/accompanying-mode-hook
  (defcustom esc/accompanying-mode-hook nil
    "Hook that is appended to esc-mode-hook."
    :type         'hook
    :options      '(;; do's
                    (when (fboundp 'ido-mode) (ido-mode (esc-mode-enabledp)))
                    (when (fboundp 'eldoc-mode) (eldoc-mode (esc-mode-enabledp)))
                    (when (fboundp 'winner-mode) (winner-mode (esc-mode-enabledp)))
                    (when (fboundp 'keyfreq-mode) (keyfreq-mode (esc-mode-enabledp)))
                    (when (fboundp 'recentf-mode) (recentf-mode (esc-mode-enabledp)))
                    (when (fboundp 'icomplete-mode) (icomplete-mode (esc-mode-enabledp)))
                    (when (fboundp 'guide-key-mode) (guide-key-mode (esc-mode-enabledp)))
                    (when (fboundp 'auto-fill-mode) (auto-fill-mode (esc-mode-enabledp)))
                    (when (fboundp 'show-paren-mode) (show-paren-mode (esc-mode-enabledp)))
                    (when (fboundp 'line-number-mode) (line-number-mode (esc-mode-enabledp)))
                    (when (fboundp 'display-time-mode) (display-time-mode (esc-mode-enabledp)))
                    (when (fboundp 'column-number-mode) (column-number-mode (esc-mode-enabledp)))
                    (when (fboundp 'which-function-mode) (which-function-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-hl-line-mode) (global-hl-line-mode (esc-mode-enabledp)))
                    (when (fboundp 'display-battery-mode) (display-battery-mode (esc-mode-enabledp)))
                    (when (fboundp 'autopair-global-mode) (autopair-global-mode (esc-mode-enabledp)))
                    (when (fboundp 'auto-compression-mode) (auto-compression-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-on-screen-mode) (global-on-screen-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-font-lock-mode) (global-font-lock-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-auto-revert-mode) (global-auto-revert-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-rainbow-delimiters-mode) (global-rainbow-delimiters-mode (esc-mode-enabledp)))
                    ;; dont's
                    (when (fboundp 'tool-bar-mode) (tool-bar-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'menu-bar-mode) (menu-bar-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'scroll-bar-mode) (scroll-bar-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'blink-cursor-mode) (blink-cursor-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'transient-mark-mode) (transient-mark-mode (dont (esc-mode-enabledp)))))
    :group        'esc-mode)
#+END_SRC

** esc macros
#+NAME: self inflection
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defmacro esc-mode-enabledp ()
      "A macro to determine if \\[esc-mode] is currently enabled."
      `(progn (and (boundp 'esc-mode) esc-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
    (after 'diminish-autoloads
      (defmacro diminish-or-restore (mode)
        "A macro to diminish a MODE, if `esc-mode' is being enabled;
              or disable a MODE, if `esc-mode' is being disabled."
        `(progn
           (after 'diminish-autoloads
             (if (esc-mode-enabledp)
                 (diminish ,mode)
               (diminish-undo ,mode))))))
#+END_SRC

Never you mind this macros...
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defmacro dont (operand)
    "A macro to avoid awkward, unintuitive code in \\[esc-accompanying-mode-hook].
            OPERAND is an integer to de/activate a given mode."
    `(progn
       (if (numberp ,operand)
           (* (- 1) ,operand)
         (if ,operand nil t))))
#+END_SRC

Macros to insert bindings in =esc-mode-map=.
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
    (defmacro esc-key (sequence action)
      "A macro to bind SEQUENCE to ACTION in `esc-mode-map'."
      `(define-key esc-mode-map (kbd ,sequence) ,action))

    (defmacro esc-keys (&rest binding-list)
      "A macro to bind all keybindings and functions in BINDING-LIST
    in `esc-mode-map'.

    This macro runs conses through \\[esc-key] for convenience."
      (declare (indent defun))
      `(mapc (lambda (binding) (esc-key (car binding) (cdr binding)))
             '(,@binding-list)))
#+END_SRC

Below is the forge, boilerplate functions are churned out en-masse.
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defmacro esc/define-displaced-yank (funcname data)
    "This macro generates functions for `esc-mode-map'."
    (let ((funcname (intern (format "esc/yank-displaced-%s" funcname)))
          (str (car data))
          (back (or (cadr data) 1)))
      (let ((docstring (format "Insert %s ARG times." str)))
      `(defun ,funcname (&optional ARG)
         ,docstring
         (interactive "p")
         (dotimes (i ARG)
           (insert ,str)
           (backward-char ,back))))))

  (mapcar (lambda (function)
            (let ((funcname (car function))
                  (data     (cdr function)))
              (eval `(esc/define-displaced-yank ,funcname ,data))))
          '((parens              "()")
            (braces              "{}")
            (brackets            "[]")
            (brackets-with-colon "[:]")
            (pipes               "||")
            (chevrons            "<>")
            (quotes              "\"\"")
            (single-quotes       "''")
            (stars               "**")
            (dollars             "$$")
            (equals              "==")
            ;; a good example of code reuse
            (ticks               "`'")
            (little-arrow        "->" 0)
            (doxygen-comment     "/*!  */" 3))) ;; todo: implement with yasnippet

  ;; todo: use current line in absence of region
  (defmacro esc/define-org-header-indentation(funcname callback)
    "Define functions to manipulate the header level of selected
  region in `org-mode'."
    (let ((command-name (intern (format "esc/org-%s-headers-in-region" funcname)))
          (docstring (format "%s `org-mode' headers arg times in currently
  selected region."
                             funcname)))
    `(defun ,command-name (&optional arg)
       ,docstring
       (interactive "p")
       (save-excursion
         (let ((beg (save-excursion
                      (goto-char (region-beginning)) (beginning-of-line) (point)))
               (end (save-excursion
                      (goto-char (region-end)) (end-of-line) (point))))
           (goto-char end)
           (while (and (< beg (point))
                       (re-search-backward "^\*" beg 'noerror))
             (dotimes (i arg) ,callback)
             (previous-line)
             (end-of-line)))))))

  (mapcar (lambda (data)
            (let ((funcname (car data))
                  (callback (cadr data)))
              (eval `(esc/define-org-header-indentation ,funcname ,callback))))
          '((indent (insert "*"))
            (unindent (kill-forward-chars 1))))

  (defmacro esc/define-scroll-slight(funcname)
    "Define functions to scroll the buffer slightly without moving point."
    (let ((docstring (format "Scroll %s the page ARG times without
  moving point. The number of lines to scroll is determined by the
  variable `esc-line-shift-amount'.

  This command can be prefixed." funcname))
          (command-name (intern (format "esc/scroll-%s-slight" funcname)))
          (command (intern (format "scroll-%s" funcname))))
      `(defun ,command-name(&optional arg)
         ,docstring
         (interactive "p")
         (dotimes (i arg)
           (,command esc-line-shift-amount)))))

  (mapcar (lambda (data) (eval `(esc/define-scroll-slight ,data)))
          '(up down))

  (defmacro esc/define-zoom(funcname operation)
    "Define functions to zoom into and out of a buffer."
    (let ((command (intern (format "esc/zoom-%s" funcname)))
          (docstring (format "Zoom %s on the font in all buffers by
  `esc-zoom-amount' points.

  This command can be prefixed." funcname)))
      `(defun ,command(arg)
         ,docstring
         (interactive "p")
         (dotimes (i arg)
           (set-face-attribute 'default nil
                               :height (,operation
                                        (face-attribute 'default :height)
                                        esc-zoom-amount))))))

  (mapcar (lambda (data)
            (let ((funcname (car data))
                  (command (cadr data)))
              (eval `(esc/define-zoom ,funcname ,command))))
          '((in  +)
            (out -)))
#+END_SRC

** esc bindings
#+NAME: keybindings defined here
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  ;; Windmove from shift keys
  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))

  (after 'expand-region-autoloads      ;Three guesses [[https://github.com/magnars/expand-region.el][who]]
    (esc-key "C-=" 'er/expand-region)) ;wrote this package

  ;; Helm
  (after 'helm-autoloads
    (esc-keys
      ("C-c i"   . helm-imenu)
      ("C-x C-j" . helm-for-files)))

  ;; todo: pull buffer management into another hydra
  ;; Enhanced keybindings
  (esc-keys
    ("C-'"     . execute-extended-command)
    ("M-g"     . esc/goto-line-with-feedback)
    ("C-j"     . newline-and-indent) ;for consistency in *scratch*
    ("C-a"     . esc/back-to-indentation-or-beginning)
    ("s-z"     . other-window)
    ("C-x 4 k" . esc/mode-line-other-buffer-other-window)
    ("C-x 4 9" . esc/bury-buffer-delete-window)
    ("M-x"     . execute-extended-command)
    ("C-'"     . query-replace)
    ("C-x M-r" . revert-buffer-no-confirm)
    ("C-x 2"   . esc/vsplit-last-buffer)
    ("C-x 3"   . esc/hsplit-last-buffer)
    ("M-s o"   . occur-dwim)

    ;; Equivalent to middle-click yank on mouse
    ("C-c y" . esc/middle-click-yank)


    ;; Miscellaneous keybindings
    ("C-c a"   . org-agenda)
    ("M-K"     . kill-sentence)
    ("M-z"     . zap-up-to-char) ; up-to, life saver
    ("M-Z"     . zap-to-char)
    ("M-j"     . just-one-space) ; conflicts with spotlight
    ("C-c k"   . esc/copy-line)
    ("M-P"     . align-regexp)
    ("C-c e"   . esc/eval-and-replace)
    ("C-c C-b" . mode-line-other-buffer)
    ;; TODO: change sexp wrapping (i.e. {}[]()) from Xah Lee

    ;; todo: paxedit in a hydra

    ;; todo: single mode should be one hydra
    ;; f-related-keybindings
    ("C-x F"   . recentf-open-files)
    ("C-x f"   . esc/toggle-selective-display)
    ("C-x M-f" . single/ff-in-single-mode)

    ;; Fold-this keybindings. Thanks again [[https://github.com/magnars/fold-this.el][Magnar]]!
    ("C-c f"   . fold-this)
    ("C-c F"   . fold-this-unfold-all)

    ;; ido-extras keybindings
    ("M-i"       . ido-goto-symbol)
    ("C-x C-r"   . ido-recentf-open)
    ("C-x C-S-r" . find-file-read-only)

    ;; Programming bindings
    ("C-c m" . compile)
    ("C-c C-m" . recompile)

    ;; C-q cluster
    ("C-q"     . delete-region)  ;like C-w, but gone
    ("C-c q"   . auto-fill-mode) ;more frequented than
    ("C-c C-q" . quoted-insert)   ;this command

    ;; newline creation
    ("<C-return>"   . esc/open-line-below)
    ("<C-S-return>" . esc/open-line-above)

    ;; LaTeX bindings
    ;; todo: hydratize that block
    ("C-c l b" . esc/insert-latex-block)

    ;; Minimap bindings
    ("C-c C-/" . esc/minimap-toggle)

    ;; Ace jump mode. Like an ace
    ;; todo: hydratize
    ("C-c SPC" . ace-jump-mode)
    ("C-x SPC" . ace-jump-mode-pop-mark)
    ("C-M-S-l" . ace-jump-buffer)
    ("C-M-O" . split-line)

    ;; Mark commands
    ("C-x m" . pop-to-mark-command)

    ;; Lisp/sexp movement
    ("C-S-k" . kill-sexp)

    ;; Preserving stock org functionality
    ("C-c l l" . org-store-link)

    ;; Buffer control
    ("C-x C-b" . global-git-gutter+-mode) ; every invocation was accidental
    ("C-x M-b" . bury-buffer)
    ("C-x M-B" . esc/bury-other-buffer)
    ("C-c o"   . clone-indirect-buffer-other-window)
    ("C-c C-o" . ff-find-other-file)

    ;; Git-messenger, a handy little fella
    ("C-c p" . git-messenger:popup-message)

    ;; todo: hydratize?
    ;; Help+
    ("C-h C-f"   . find-function)
    ("C-h C-k"   . find-function-on-key)
    ("C-h C-v"   . find-variable)
    ("C-h C-l"   . find-library)
    ("C-h C-n"   . esc/insert-defun-at-point)
    ("C-h M-k"   . describe-keymap)
    ("C-h C-M-c" . esc/insert-key-combination)

    ;; Un- and re- doing
    ("C-c /"   . goto-last-change)

    ;; Font maniplation
    ("C-M-<" . esc/zoom-out)
    ("C-M->" . esc/zoom-in)

    ;;; Function keys
    ("<f6>" . spray-mode)
    ("<f7>" . scroll-all-mode)
    ("<f8>" . follow-delete-other-windows-and-split)
    ("<f9>" . flyspell-buffer)
    ("<f10>" . golden-ratio-mode)
    ;; TODO: create a defun to save win configuration first
    ;; see stack on zebulon

    ;; Sysadmin bindings
    ;; TODO: bookmarks to dotfiles and esc-lisp

    ;; esc delimeter and line hacks
    ("C-<backspace>" . esc/backward-delete-word)
    ("M-k"    . esc/pull-up-line)
    ("C-M--"  . esc/yank-displaced-little-arrow)
    ("C-M-j"  . esc/yank-displaced-parens)
    ("C-M-k"  . esc/yank-displaced-braces)
    ("C-M-|"  . esc/yank-displaced-pipes)
    ("C-M-l"  . esc/yank-displaced-brackets)
    ("C-M-,"  . esc/yank-displaced-chevrons)
    ("C-M-'"  . esc/yank-displaced-single-quotes)
    ("C-M-\"" . esc/yank-displaced-quotes)
    ("C-M-*"  . esc/yank-displaced-stars)
    ("C-M-g"  . esc/yank-displaced-dollars)
    ("C-M-="  . esc/yank-displaced-equals)
    ("C-M-`"  . esc/yank-displaced-ticks)

    ("M-'"   . toggle-quotes)

    ;; Buffer-overlay hacks: super useful!
    ("s-e" . esc/raise-eshell)
    ;; todo: raise shell
    ;; todo: smarter magit status: use zebulon's stack package
    ("s-q" . esc/raise-magit-status))
#+END_SRC

I don't know where smartrep defines keys but this worked for me and I
haven't had to look at it yet.
#+BEGIN_SRC emacs-lisp :tangle no
  (smartrep-define-key global-map "C-c ."
    '(("+" . apply-operation-to-number-at-point)
      ("-" . apply-operation-to-number-at-point)
      ("*" . apply-operation-to-number-at-point)
      ("/" . apply-operation-to-number-at-point)
      ("\\" . apply-operation-to-number-at-point)
      ("^" . apply-operation-to-number-at-point)
      ("<" . apply-operation-to-number-at-point)
      (">" . apply-operation-to-number-at-point)
      ("#" . apply-operation-to-number-at-point)
      ("%" . apply-operation-to-number-at-point)
      ("'" . operate-on-number-at-point)))
#+END_SRC

** esc hydras
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (setq hydra-lv nil)

  (defhydra hydra-text-scale (esc-mode-map  "<f2>")
    "text-scale"
    ("k" text-scale-increase)
    ("j" text-scale-decrease))

  (defhydra hydra-zoom (esc-mode-map  "C-<f2>")
    "esc/zoom"
    ("," esc/zoom-out)
    ("." esc/zoom-in))

  (defhydra hydra-error (esc-mode-map "M-g")
    "goto-error"
    ("h" first-error "first")
    ("j" next-error "next")
    ("k" previous-error "prev")
    ("l" esc/goto-line-with-feedback "goto-line" :color blue))

  (defhydra hydra-multiple-cursors (esc-mode-map "M-a")
    "multiple-cursors"
    ("l" mc/edit-lines "edit")
    ("n" mc/mark-next-like-this "mark next")
    ("p" mc/mark-previous-like-this "mark prev")
    ("s" mc/sort-regions "sort")
    ("r" mc/reverse-regions "reverse")
    ("e" mc/insert-numbers "enumerate")
    ("*" mc/mark-all-like-this "mark all")
    ("o" mc/mark-all-like-this-dwim "mark all dwim"))

  (defhydra hydra-word-at-point (esc-mode-map "C-S-s")
    "word at point"
    ("r" esc/search-word-backward "search-backward")
    ("s" esc/search-word-forward "search-forward"))

  ;; todo: move to beginning of word in pre hook
  (defhydra hydra-case-word-at-point (esc-mode-map "C-S-l")
    "case word at point"
    ("c" capitalize-word "capitalize")
    ("u" upcase-word "upcase")
    ("l" downcase-word "lowercase"))

  (defhydra hydra-scroll-buffer (esc-mode-map "M-n")
    "cursor-movement"
    ("j" esc/scroll-up-slight "scroll up")
    ("k" esc/scroll-down-slight "scroll down")
    ("s" isearch-forward "isearch-f" :color blue)
    ("r" isearch-backward "isearch-r" :color blue)
    ("n" next-line "next-line")
    ("p" previous-line "prev-line")
    ("e" end-of-line "end-of-line")
    ("a" beginning-of-line "beg-of-line")
    ("d" scroll-up "page up")
    ("u" scroll-down "page down")
    ("q" kill-buffer))

  (defhydra hydra-window-adjustment (esc-mode-map "C-z")
    "window adjustment"
    ("r" esc/rotate-window-split "rotate")
    ("p" esc/swap-buffer-locations "swap")
    ("o" esc/should-have-opened-this-in-other-window "other window")
    ("s" esc/toggle-window-selectability "toggle selectability")
    ("w" ace-window "ace-window")
    ("d" esc/toggle-window-dedicated "toggle dedicated")
    ("b" mode-line-other-buffer "mode-line-other-buffer")
    ("u" bury-buffer "bury"))

  (after 'org
    (defhydra hydra-org-nav-source-block (esc-mode-map "C-c n")
      "org src block nav"
      ("n" esc/org-next-source-code-block "next")
      ("p" esc/org-prev-source-code-block "prev")))

  (defhydra hydra-move-text (esc-mode-map "M-RET")
    "move text"
    ("j" move-text-down "down")
    ("k" move-text-up "up"))

  (defhydra hydra-hide-lines (esc-mode-map "C-c h")
    "hide lines"
    ("h" hide-lines "hide")
    ("r" esc/reveal-all-hidden-lines "reveal all"))
#+END_SRC

** esc hook
#+NAME: esc-mode-hook
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  ;; The proper definition of `esc-mode-hook'
  (defun esc/accompanying-mode-hook ()
    "esc's customizations added to \\[esc-mode-hook]."
    (let ((activate-bool (esc-mode-enabledp)))
      (setq activate (if activate-bool 1 -1))
      ;; esc-mode wouldn't be complete without these helper modes

      ;; activate these modes
      (mapc (lambda (mode) (when (fboundp mode)
                               (ignore-errors (funcall mode activate))))
            '(ido-mode
              eldoc-mode
              winner-mode
              keyfreq-mode
              recentf-mode
              icomplete-mode
              guide-key-mode
              auto-fill-mode
              show-paren-mode
              line-number-mode
              display-time-mode
              column-number-mode
              which-function-mode
              global-hl-line-mode
              display-battery-mode
              autopair-global-mode
              auto-compression-mode
              global-on-screen-mode
              global-font-lock-mode
              global-auto-revert-mode
              global-rainbow-delimiters-mode))

      ;; deactivate these modes
      (mapc (lambda (mode) (when (fboundp mode)
                               (funcall mode (dont activate))))
            '(tool-bar-mode
              menu-bar-mode
              scroll-bar-mode
              blink-cursor-mode
              transient-mark-mode))

      ;; esc-mode enjoys these settings also
      (when (fboundp 'global-git-gutter-mode)
        (global-git-gutter-mode activate-bool))
      (setq-default save-place       activate-bool
                    abbrev-mode      activate-bool
                    auto-revert-mode activate-bool)
      (diminish 'auto-revert-mode)
      (setq
       display-time-24hr-format             activate-bool
       global-auto-revert-non-file-buffers  activate-bool
       next-line-add-newlines               activate-bool
       kill-whole-line                      activate-bool
       vc-follow-symlinks                   activate-bool
       search-highlight                     activate-bool
       query-replace-highlight              activate-bool
       auto-revert-verbose                  (not activate-bool)
       confirm-nonexistent-file-or-buffer   (not activate-bool))

      ;; TODO: this was determined to have a bug in it. Handle the bug
      ;;(setq revert-buffer-function (if (esc-mode-enabledp)
      ;;                                 'revert-buffer-keep-undo
      ;;                               'revert-buffer))

      ;; TODO: clean up this garbage (but keep functionality)
      ;;   - possibility: wrap with 'ignore-errors
      (if (<= emacs-major-version 23)
          (message "Old Emacs prevents visual-line-mode, auto-complete-mode")
        (global-visual-line-mode activate) ;word wrap by default
        (diminish 'visual-line-mode)
        (after 'auto-complete
          (global-auto-complete-mode activate))) ;in all buffers

      (after 'undo-tree-autoloads
        (global-undo-tree-mode activate)
        (setq undo-tree-visualizer-timestamps t
              undo-tree-visualizer-relative-timestamps t))

      ;; less clutter on the mode line
      (diminish 'auto-fill-function)
      (diminish 'visual-line-mode)
      ;;(diminish 'global-visual-line-mode)
      (after 'autopair  (diminish 'autopair-mode))
      (after 'abbrev    (diminish 'abbrev-mode))
      (after 'undo-tree (diminish 'undo-tree-mode))
      (after 'org-indent (diminish 'org-indent-mode))
      (after 'magit (diminish 'magit-auto-revert-mode))
      (after 'fic-mode (diminish 'fic-mode))
      (after 'eldoc (diminish 'eldoc-mode))
      (after 'smerge-mode (diminish 'smerge-mode))
      (after 'auto-complete (diminish 'auto-complete-mode))))
      (after 'esc-mode (diminish 'esc-mode))
#+END_SRC
#+NAME: activate esc-mode-hook
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (add-hook 'esc-mode-hook 'esc/accompanying-mode-hook)
#+END_SRC
#+NAME: activate esc-mode
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (esc-mode 1)
  ;(diminish-or-restore 'esc-mode) ;in the background
#+END_SRC
#+NAME: esc provides
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (provide 'esc-mode)
#+END_SRC

* Fin
#+BEGIN_SRC emacs-lisp :tangle yes
  (message "All done, %s%s" (user-login-name) ".")
  ;;; .emacs.el ends here
#+END_SRC
* [6/19] TODOs
** DONE fix load path
** DONE quick dictionary
** DONE remove tangles files from git, provide makefile
** DONE allow tabs in makefile-mode
  works with tabify
** DONE byte-compile-directory
** DONE diminish stuff
** TODO activate =size-indication-mode= with =power-line-mode=
** TODO make powerline part of esc-mode
** TODO scratch buffer as consistent config file
  only emacs-lisp source blocks from the org file are loaded,
  naturally
** TODO tangling scripts adds execute permission
  (write-region "" nil custom-file)
** TODO smooth esc scrolling
  best definition so far: scrolling that increases over time
** TODO naming standard for org babel files sectioning
** TODO gcov output parsed by emacs to hilight gdb code coverage
** TODO use package use-package
** [0/1] Dired
*** TODO human readable sizes in dired
  First have to determine how to unhide information on demand
  for definitions, not spell check
** [0/2] advice
*** TODO C-h C-k takes you to org instead of .el
*** TODO C-x M-r to save undo information
** [0/2] ibuffer-vc
*** TODO create mode to replace sort-by -mode with -ssh host
*** TODO make it group files over tramp
