#+AUTHOR: Eric Crosson
#+EMAIL: esc@ericcrosson.com
#+STARTUP: content
* Introduction
#+NAME: program-license
#+BEGIN_SRC emacs-lisp :tangle yes
    ;;; .emacs.el

    ;;; Commentary:
    ;;; This is the .emacs file written and used by esc. The .el file is
    ;;; not the original form of this document; it was written in org
    ;;; babel. If you are not viewing the org document, you should try to
    ;;; locate it. It's much nicer to humans.

    ;;; License:
    ;;; esc's .emacs configuration file, for a smoother Emacs experience.
    ;;; Copyright (C) 2013 Eric Crosson
    ;;;
    ;;; This program is free software: you can redistribute it and/or modify
    ;;; it under the terms of the GNU General Public License as published by
    ;;; the Free Software Foundation, either version 3 of the License, or
    ;;; (at your option) any later version.
    ;;;
    ;;; This program is distributed in the hope that it will be useful,
    ;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
    ;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    ;;; GNU General Public License for more details.
    ;;;
    ;;; You should have received a copy of the GNU General Public License
    ;;; along with this program. If not, see <http://www.gnu.org/licenses/>.

    ;;; Code:
#+END_SRC
Now that the legal stuff is out of the way, let's get out the rat poison.
#+NAME: ratpoison
#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc (lambda (mode) (when (fboundp mode) (funcall mode -1)))
        '(menu-bar-mode
          tool-bar-mode
          scroll-bar-mode))
#+END_SRC

- [ ] TODO: load this with color-stack

#+NAME: mood lighting
#+BEGIN_SRC emacs-lisp :tangle yes
  (load-theme 'wombat)
#+END_SRC
* [1/15] TODOs
:PROPERTIES:
:COOKIE_DATA: recursive
:END:
- [ ] fix load path
  #+BEGIN_SRC fundamental
    Warning (initialization): Your `load-path' seems to contain
    your `.emacs.d' directory: /home/eric/.emacs.d
    This is likely to cause problems...
    Consider using a subdirectory instead, e.g.: /home/eric/.emacs.d/lisp
  #+END_SRC
- [ ] scratch buffer as consistent config file
  only emacs-lisp source blocks from the org file are loaded,
  naturally
- [ ] convert to use-package
- [X] remove tangles files from git, provide makefile
- [ ] tangling scripts adds execute permission
  (write-region "" nil custom-file)
- [ ] allow tabs in makefile-mode
- [ ] advise (kbd "C-x M-r") like you did revert-buffer
  Is this necessary?
- [ ] 'jump to aligned column'
- [ ] smooth esc scrolling
- [ ] human readable sizes in dired
  First have to determine how to unhide information on demand
- [ ] windmove in org buffers
- [ ] quick dict(ionary)
  for definitions, not spell check
- [ ] naming standard for org babel files sectioning
- [ ] gcov output parsed by emacs to hgihlight covered code in gdb
  mode
- [ ] byte-compile-directory
  (byte-recompile-directory (expand-file-name "~/.emacs.d") 0)
  mirror byte-compile-file's method of querying file to compile
** [0/1] advice to implement
- [ ] C-h C-k takes you to org instead of .el
** [0/2] ibuffer upgrades
- [ ] ibuffer, create mode to replace sort-by -mode with -ssh host
- [ ] ibuffer-vc, make it group files over tramp
* Free variables

This section declares variables to prevent compiler warnings.

#+NAME: free as in free of compiler warnings
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-when-compile
    (defvar package-user-dir)
    (defvar package-archives)
    (defvar uniquify-separator)
    (defvar uniquify-buffer-name-style)
    (defvar save-place-file)
    (defvar display-time-load-average-threshold)
    (defvar dabbrev-case-replace)
    (defvar compilation-save-buffers-predicate)
    (defvar starttls-use-gnutls)
    (defvar recentf-auto-cleanup)
    (defvar c-default-style)
    (defvar c-basic-offset)
    (defvar ido-create-new-buffer)
    (defvar desktop-save)
    (defvar desktop-path)
    (defvar desktop-base-filename)
    (defvar desktop-load-locked-desktop)
    (defvar ff-always-in-other-window)
    (defvar ff-always-try-to-create)
    (defvar ff-search-directories)
    (defvar eshell-mode-map)
    (defvar eshell-where-to-jump)
    (defvar eshell-review-quick-commands)
    (defvar eshell-smart-space-goes-to-end)
    (defvar w3m-mode-map)
    (defvar iedit-mode-keymap)
    (defvar w32-pass-lwindow-to-system)
    (defvar w32-pass-rwindow-to-system)
    (defvar w32-pass-apps-to-system)
    (defvar w32-lwindow-modifier)
    (defvar w32-rwindow-modifier)
    (defvar w32-apps-modifier)
    (defvar mac-command-modifier)
    (defvar mac-option-modifier)
    (defvar ns-function-modifier)
    (defvar dired-mode-map)
    (defvar org-replace-disputed-keys)
    (defvar org-clock-persist)
    (defvar org-hide-leading-stars)
    (defvar org-hide-emphasis-markers)
    (defvar org-src-fontify-natively)
    (defvar org-agenda-files)
    (defvar org-confirm-babel-evaluate)
    (defvar display-time-24hr-format)
    (defvar global-auto-revert-non-file-buffers)
    (defvar auto-revert-verbose))

#+END_SRC
* Load path creation

This is a neat trick I found to take away 99.9% of the headache when
dealing with Emacs' load path. Assuming the user has placed every
file, script and dependency in his or her =~/.emacs.d/= directory,
this block will ensure Emacs can find each file come load time. No
need to keep the list updated, just load all subdirectories and go.

#+NAME: load-path-creation
#+BEGIN_SRC emacs-lisp :tangle yes
  (defcustom site-lisp-path nil
    "Path to esc's lisp library."
    :type 'path
    :options '("~/.emacs.d/site-lisp/")
    :group 'esc-mode)
  (setq site-lisp-path "~/.emacs.d/site-lisp/")

  (defcustom esc-lisp-path nil
    "Path to esc's lisp library."
    :type 'path
    :options '("~/.emacs.d/site-lisp/esc-lisp/")
    :group 'esc-mode)
  (setq esc-lisp-path (concat site-lisp-path "esc-lisp/"))

  (defcustom esc-loaddefs-path nil
    "Path to `loaddefs.el' file used by esc's Emacs sessions."
    :type 'path
    :options '("~/.emacs.d/site-lisp/esc-lisp/loaddefs.el")
    :group 'esc-mode)
  (setq esc-loaddefs-path (concat esc-lisp-path "loaddefs.el"))

  (let ((default-directory site-lisp-path))       ;for easy
    (normal-top-level-add-to-load-path '("."))   ;recursive
    (normal-top-level-add-subdirs-to-load-path)) ;loading

  (autoload 'list-files-in-subtree-matching-regexp-recursive
    (concat esc-lisp-path "update-autoloads/update-autoloads.el"))
  ;; Load all project's loaddefs.el (automatically managed)
  (mapc (lambda (loaddef) (load-file loaddef))
        (list-files-in-subtree-matching-regexp-recursive
         esc-lisp-path "loaddefs.el"))
#+END_SRC

* Macros

I took the macro below from [[http://milkbox.net/note/single-file-master-emacs-configuration/][milkypostman]]. His article is really worth
a read; stop what you're doing and go take a look if you haven't.

#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro after (mode &rest body)
  "`eval-after-load' MODE evaluate BODY."
  (declare (indent defun))
  `(eval-after-load ,mode
     '(progn ,@body)))
#+END_SRC

A macro to wrap code execution in those handy \*Messages\* style
notifications.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro message-progress (message &rest body)
    "Message MESSAGE and run BODY. Then message MESSSAGE...done."
    (declare (indent defun))
    `(progn
       (message ,message)
       (progn ,@body)
       (message (concat ,message "...done"))))
#+END_SRC

The macros below are to facilitate loading with minimal code. This is
lisp; we use lists. Get used to it, they're pretty great.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro autoload-from-package (package functions)
    "From PACKAGE (string), autoload FUNCTIONS (list)."
    (declare (indent defun))
    `(mapc (lambda (fn) (autoload fn ,package nil t))
           ,functions))

  (defmacro require-package (packages)
    "Require PACKAGES (list) quietly."
    (declare (indent defun))
    `(mapc (lambda (package) (require package nil 'noerror))
           ,packages))
#+END_SRC

* Auto-compile configuration

  Set up [[https://github.com/tarsius/auto-compile][auto-compile mode]] to compile source files before loading iff
  source is newer than the presently compiled file. A good tradeoff
  with proper distributed version control.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq load-prefer-newer t)
    (require-package '(auto-compile))
    (auto-compile-on-load-mode 1)
  #+END_SRC

* Package configuration
#+NAME: package-manager-initialization
#+BEGIN_SRC emacs-lisp :tangle yes
  (when (require 'package nil 'noerror)
    (setq package-user-dir "~/.emacs.d/elpa/")
    (mapc (lambda (source)
              (add-to-list 'package-archives source) t)
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("marmalade" . "http://marmalade-repo.org/packages/")
            ("melpa-stable" . "http://melpa-stable.milkbox.net/packages/")
            ("melpa" . "http://melpa.milkbox.net/packages/")))
    (package-initialize))
#+END_SRC

* User metadata

Hello, My Name Is

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq user-full-name "Eric Crosson"
        user-mail-address "esc@ericcrosson.com")
#+END_SRC

* Behavioral modifications

This code is pretty dense. It should probably be broken up, but I
like the long setq syntax for now.

#+NAME: behavioral-modifications
#+BEGIN_SRC emacs-lisp :tangle yes
  (put 'overwrite-mode 'disabled t)       ;There shall be no 'insert'
  (fset 'yes-or-no-p 'y-or-n-p)           ;change yes-no to y-n
  (setq-default size-indication-mode t)
  (setq debug-on-error t
        initial-scratch-message nil
        ring-bell-function 'ignore        ;turn off alarms completely
        uniquify-separator ":"            ;needs to be set before uniquify
        uniquify-buffer-name-style 'post-forward ;is loaded
        disabled-command-function 'beep   ;alert me when accessing disabled funcs
        x-select-enable-clipboard t       ;global clipboard
        kill-ring-max 80                  ;kill ring entries
        redisplay-dont-pause t            ;don't pause refreshes
        frame-title-format '("emacs@" system-name ": %f") ;include path of frame
        save-place-file (expand-file-name "meta/places" user-emacs-directory)
        display-time-load-average-threshold 0.6
        dabbrev-case-replace nil
        ; begin deprecation: TODO fix
        display-buffer-reuse-frames t     ;raise buffers, not spawn
        ; end deprecation
        remote-file-name-inhibit-cache t  ;don't resolve remote file attrubutes
        auto-save-default nil
        inhibit-startup-screen t
        large-file-warning-threshold nil
        compile-command "make"
        compilation-ask-about-save nil
        compilation-save-buffers-predicate '(lambda () nil) ;never ask to save
        ff-search-directories '("." "../inc" "../src")
        set-mark-command-repeat-pop t
        starttls-use-gnutls t
        recentf-auto-cleanup 'never   ;must be set before recentf loaded
        mouse-yank-at-point t
        browse-url-browser-function 'w3m-browse-url
        kill-buffer-query-functions (remq 'process-kill-buffer-query-function kill-buffer-query-functions)
        minibuffer-prompt-properties '(read-only t point-entered
                                                 minibuffer-avoid-prompt face
                                                 minibuffer-prompt))
#+END_SRC

Let's reduce information generated by compiling. Your code builds, right?

#+NAME: diminish-compiler-warnings
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Diminish compiler warnings
  (setq byte-compile-warnings '(not interactive-only free-vars))
#+END_SRC

These settings keep the text soup that is GNU/Linux as happy as GNU/Linux files can be.

#+NAME: char-and-font-encoding
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Char and font encoding
  (set-buffer-file-coding-system 'unix)   ;Unix mode. Always
  (setq c-default-style "linux"
        c-basic-offset 2
        ido-create-new-buffer 'always
        require-final-newline 'visit-save ;compliance
        indent-tabs-mode nil
        comment-style 'indent)
#+END_SRC

It is my belief that backup files should not be so obtrusive as to tempt users to disable them.

#+NAME: stash-backups
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Backup settings
  (push '("." . "~/.config/.emacs.d/") backup-directory-alist)
  (desktop-save-mode 1)                   ;use desktop file
  (setq desktop-save 'if-exists                 ;save open buffers
        desktop-path '("~/emacs.d")       ;local desktop files
        desktop-base-filename "desktop"
        desktop-load-locked-desktop t     ;never freeze after crash
        backup-by-copying-when-linked t
        backup-by-copying-when-mismatch t)
#+END_SRC

* Aliases

I did not grow up in an era where this is a straightforward mnemonic.

#+NAME: alias fmakunbound => undefun
#+BEGIN_SRC emacs-lisp :tangle yes
  (defalias 'undefun 'fmakunbound)
#+END_SRC

* Advice
** org advice

Shrink the agenda buffer as small as we can.

#+NAME: Shrink agenda buffer
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice org-agenda (around shrink-agenda-buffer activate)
    "Shrink the agenda after initial display."
    ad-do-it
    (shrink-window-if-larger-than-buffer))

  ;; Also, keep it shrunken upon refresh
  (defadvice org-agenda-redo (around shrink-agenda-buffer-after-refresh activate)
    "Shrink the agenda after refreshing the display."
    ad-do-it
    (shrink-window-if-larger-than-buffer))
#+END_SRC

** advising built-in commands

The following macro is to prevent the user from manually having to
create directories (=M-x make-directory RET RET=) after using
=find-file= on a nonexistent file.

#+NAME: ensure-parent-dir-exists
#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice find-file (before make-directory-maybe
			     (filename &optional wildcards) activate)
  "Create nonexistent parent directories while visiting files."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir)))))
#+END_SRC

*** comment-dwim
I wrote a post about my path to this advice somewhere. I'll find a link when it's stable.

#+NAME: One Commenter to Rule Them All (TM)
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice comment-dwim (around comment-line-maybe activate)
    "If invoked from the beginning of a line or the beginning of
  text on a line, comment the current line instead of appending a
  comment to the line."
    (if (and (not (use-region-p))
             (not (eq (line-end-position)
                      (save-excursion (back-to-indentation) (point))))
             (or (eq (point) (line-beginning-position))
                 (eq (point) (save-excursion (back-to-indentation) (point)))))
        (comment-or-uncomment-region (line-beginning-position)
                                     (line-end-position))
      ad-do-it
      (setq deactivate-mark nil)))
#+END_SRC

Prefix '0' to comment-dwim to kill comments entirely.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice comment-dwim (around delete-comment-if-prefixed activate)
    "If the universal prefix to \\[comment-dwim] is 0, delete the
    comment from the current line or marked region."
    (if (not (eq current-prefix-arg 0))   ; normal behavior
        ad-do-it
      (let ((comments (if (region-active-p)
                          (count-lines (region-beginning) (region-end))
                        1)))
        (save-excursion
          (when (region-active-p)
            (goto-char (region-beginning)))
          (comment-kill comments)))))
#+END_SRC

TODO: write about how cool this is! (not related to above comment
about a post)

** undo tree advice
Make zipped files obvious.

#+BEGIN_SRC emacs-lisp :tangle no
  (after 'undo-tree
    (defadvice undo-tree-make-history-save-file-name
    (after undo-tree activate)
    (setq ad-return-value (concat ad-return-value ".gz"))))
#+END_SRC

* Package initialization

TODO: add optional minimum required emacs version for attempted
include to the require-package macro

#+NAME: require-packages
#+BEGIN_SRC emacs-lisp :tangle yes
  (require-package
    '(cl-lib                               ;The Golden Package
      org                                  ;The Platinum Package
      saveplace                            ;included in gnuemacs
      uniquify                             ;included in gnuemacs
      midnight                             ;included in gnuemacs
      which-func                           ;included in gnuemacs
      eldoc                                ;included in gnuemacs
      auto-complete
      notifications
      dired-x
      pretty-lambdada

      ;; custom packages
      ; is there a way to get these autoloads loaded implicitly, like
      ; elpa does?
      esc-mode                             ;The Power Glove
      cnsim-mode-autoloads
      big-fringe-mode ;; why is this here again? how to auto-load by nature of being in esc-lisp?
      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'after-save-hook 'esc/auto-byte-recompile)
#+END_SRC

* Autoloads
** Lua mode config
Lua: necessary for Awesome WM.
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "lua-mode" '(lua-mode))
  (after 'lua-mode-autoloads
    (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode)))
#+END_SRC
** Undo tree autoloads
Thanks to [[http://whattheemacsd.com/my-misc.el-02.html][Magnar]] for the advice.
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "undo-tree"
    '(undo-tree-undo
      undo-tree-redo))

  (defadvice undo-tree-undo (around keep-region activate)
    (if (use-region-p)
        (let ((m (set-marker (make-marker) (mark)))
              (p (set-marker (make-marker) (point))))
          ad-do-it
          (goto-char p)
          (set-mark m)
          (set-marker p nil)
          (set-marker m nil))
      ad-do-it))
#+END_SRC

** Spray autoloads
This mode is based on openspritz, a speedreading tutor.

#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "spray" '(spray-mode))
#+END_SRC

** Move text autoloads
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "move-text"
    '(move-text-up
      move-text-down))
#+END_SRC

** Multi term autoloads
  #+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "multi-term"
    '(multi-term
      multi-term-mext))
#+END_SRC

** Ace jump autoloads

Autoloads for ace-jump-mode proper.

#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "ace-jump-mode"
    '(ace-jump-mode
      ace-jump-mode-pop-mark))
#+END_SRC

Autoloads for ace-jump-buffer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "ace-jump-buffer"
    '(ace-jump-buffer))
#+END_SRC

Autoloads for the king, ace-window.

#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "ace-window"
    '(ace-window))
#+END_SRC

** Htmlize autoloads
  #+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "htmlize"
    '(htmlize-region
      htmlize-buffer
      htmlize-ile))
#+END_SRC

** Enhanced ruby mode
#+NAME: autoload enhanced-ruby-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload 'enh-ruby-mode "enh-ruby-mode" "Major mode for ruby files" t)
#+END_SRC
** Iedit autoloads
  #+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "iedit"
    '(iedit-mode-toggle-on-function
      iedit-prev-occurrance
      iedit-next-occurrance
      iedit-mode))
#+END_SRC

** Minimap autoloads
  #+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "minimap"
    '(minimap-kill
      minimap-create
      minimap-mode))
#+END_SRC

** Tea-time autoloads
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "tea-time"
    '(tea-time
      tea-timer-cancel))
#+END_SRC

** Scroll all mode autoloads
TODO: add hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mwheel-scroll-up-function 'mwheel-scroll-all-scroll-up-all
        mwheel-scroll-down-function 'mwheel-scroll-all-scroll-down-all)
#+END_SRC
** Miscellaneous autoloads
#+NAME: Miscellaneous autoloads
    #+BEGIN_SRC emacs-lisp :tangle yes
      (autoload-from-package "iedit"         '(iedit)) ;multi-replace
      (autoload-from-package "hide-lines"    '(hide-lines))
      (autoload-from-package "magit"         '(magit-status))
      (autoload-from-package "markdown-mode" '(markdown-mode))
      (autoload-from-package "misc"          '(zap-up-to-char))
      (autoload-from-package "misc-cmds"     '(revert-buffer-no-confirm))
      (autoload-from-package "expand-region" '(er/expand-region))
      (autoload-from-package "autopair"      '(autopair-global-mode)) ;autopair characters
      (autoload-from-package "auto-complete" '(global-auto-complete-mode)) ;autocomplete syntax
#+END_SRC
** esc's custom package autoloads

#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "single-mode"   '(single-mode)) ;an esc-package
#+END_SRC

* Hooks
** erc
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'erc-mode-hook 'esc/erc-mode-hook)
#+END_SRC

** Minibuffer setup hook

Keep the minibuffer sane.

#+NAME: minibuffer setup hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'minibuffer-setup-hook 'esc/minibuffer-setup-hook)
#+END_SRC
** ibuffer hook

Modify ibuffer view to include human readable size information.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Use human readable Size column instead of original one
  (after 'ibuffer
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 100000)  (format "%7.0fk" (/ (buffer-size) 1000.0)))
       ((> (buffer-size) 1000)    (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))

    (setq ibuffer-formats
          '((mark modified read-only         " "
                  (name 18 18  :left :elide) " "
                  (size-h 9 -1 :right)       " "
                  (mode 16 16  :left :elide) " "
                  filename-and-process))))
#+END_SRC

*** elpa packages

ibuffer-vc is great; make it automatic.

#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'ibuffer-vc-autoloads
    (defun esc/ibuffer-vc-refresh ()
      (ibuffer-vc-set-filter-groups-by-vc-root)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    (add-hook 'ibuffer-hook 'esc/ibuffer-vc-refresh))
#+END_SRC

Include vc status info in the buffer list.
Mabye I'll include this one day, for now it can live in hibernation.

#+BEGIN_SRC emacs-lisp :tangle no
  (after 'ibuffer-vc-autoloads
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 18 18 :left :elide)         " "
                  (size 9 -1  :right)               " "
                  (mode 16 16 :left :elide)         " "
                  (vc-status 16 16 :left)           " "
                  filename-and-process))))
#+END_SRC

** Prog mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook 'esc/prog-mode-hook)
#+END_SRC
** FIC-mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook 'turn-on-fic-mode)
#+END_SRC
** Tea-time hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'notifications
    (defun esc/notify-tea-steeped ()
      (notifications-notify :title "Tea time"
                            :body "Rip out that sac, because your tea bag is done"
                            :app-name "Tea Time"
                            :sound-name "alarm-clock-elapsed"))
    (add-hook 'tea-time-notification-hook 'esc/notify-tea-steeped))
#+END_SRC
** Fundamental mode
#+NAME: Fundamental mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'fundamental
    (add-hook 'fundamental-mode-hook 'esc/fundamental-mode-hook))
#+END_SRC
** Very Large File mode
Configure options for transparent handling of very large files.
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'vlf-integrate
    (vlf-set-batch-size (* 10 1024))    ;1.mb
    (custom-set-variables
     '(vlf-application 'dont-ask)))
#+END_SRC
** Text mode
#+NAME: Text mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
** Conf mode
#+NAME: auto conf-mode for text soup
#+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list
     'auto-mode-alist
     '("\\.\\(screenrc\\)\\'" . conf-mode))
#+END_SRC
** YAML mode
#+NAME: auto yaml-mode for esc's strange filenaming conventions
#+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list
     'auto-mode-alist
     '("\\.\\(taml\\)\\'" . yaml-mode))
#+END_SRC
** Web mode

TODO: disable autopair-mode for web-mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.jsp$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
#+END_SRC

** Ruby mode

Verbatim from the [[http://www.emacswiki.org/emacs/RubyMode][emacswiki]].

#+NAME: configure-enhance-ruby-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.rb$" . enh-ruby-mode))
  (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
  (add-to-list
   'auto-mode-alist
   '("\\.\\(?:gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'"
     . enh-ruby-mode))
  (add-hook 'enh-ruby-mode-hook 'esc/enh-ruby-mode-hook)
#+END_SRC
** Saveplace
#+NAME: saveplace configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(after 'saveplace
    (setq save-place-file (concat user-emacs-directory "meta/saveplace.el"))
    (setq-default save-place t))
#+END_SRC

** Recentf
#+NAME: recentf configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'recentf
    (setq recentf-max-menu-items 25
          recentf-max-saved-items 25
          recentf-keep '(file-remote-p file-readable-p)))
#+END_SRC

** Find-file hook
#+NAME: never see dos line endings again
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'find-file-hook (lambda() (esc/remove-dos-eol)))
#+END_SRC
** Flyspell mode
#+NAME: Flyspell mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'flyspell-mode
    (setq flyspell-issue-message-flag nil))
#+END_SRC

** Doc view mode
#+NAME: doc-view configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'doc-view-mode
    (setq doc-view-continuous t))
#+END_SRC

** Abbrev mode
#+NAME: abbrev-mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'abbrev-mode
    (setq abbrev-file-name "~/emacs.d/abbrev.lst"
          save-abbrevs t)
    (if (file-exists-p abbrev-file-name) ;load custom abbrevs
        (quietly-read-abbrev-file)))
#+END_SRC

** Auto-complete mode
#+NAME: auto-complete mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'auto-complete-mode
    (ac-config-default)
    (add-to-list 'ac-dictionary-directories
                 "~/.emacs.d/auto-complete/ac-dict"))
#+END_SRC

** Emacs lisp mode hook
#+NAME: emacs-lisp-mode hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'emacs-lisp-mode-hook 'esc/emacs-lisp-mode-hook)
#+END_SRC

** Lexbind mode
#+NAME: lexbind-mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'lexbind-mode
    (add-hook 'emacs-lisp-mode-hook 'lexbind-mode))
#+END_SRC

** LaTeX config
Sounded like a good idea thanks to [[http://orgmode.org/worg/org-tutorials/org-latex-export.html][orgmode.com]].

#+NAME: LaTeX configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'latex-mode
    ;; (add-to-list 'org-export-latex-classes
    ;;           '("article"
    ;;             "\\documentclass{article}"
    ;;             ("\\section{%s}" . "\\section*{%s}")
    ;;             ("\\subsection{%s}" . "\\subsection*{%s}")
    ;;             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
    ;;             ("\\paragraph{%s}" . "\\paragraph*{%s}")
    ;;             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    (load "auctex.el" nil t t)
    (load "preview-latex.el" nil t t)
    (setq TeX-command-default "latex"
          TeX-auto-save t
          TeX-parse-self t
          TeX-PDF-mode t
          latex-run-command "pdflatex")
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (local-set-key (kbd "C-c C-s") 'latex-math-preview-expression))
  ;; (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC

** C mode hook
#+NAME: c-mode-common hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'c-mode-common-hook 'esc/c-mode-common-hook)
#+END_SRC
** C++ config
#+NAME: recognize template files as c++
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'c++-mode-hook 'esc/c++-mode-hook)
  (add-to-list 'auto-mode-alist '("\\.tcc$" . c++-mode))
#+END_SRC
** Idle highlight mode
#+NAME: idle highlight configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'idle-highlight
    (setq-default idle-highlight-idle-time 10.0))
#+END_SRC
** Ansi-term config

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
    "Kill `term-mode' buffers when an exit signal is received."
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))

  (defadvice ansi-term (before force-bash)
    "Always use bash for `ansi-term'."
    (interactive (list my-term-shell)))

  (defvar my-term-shell "/bin/bash")

  (after 'term
  ;(autoload-from-package "boilerplate" 'esc/term-paste) ;;-already loaded! on TODO
    (add-hook 'term-mode-hook
              (lambda()
                (autopair-mode -1)
                (setq term-buffer-maximum-size 0 ;keep entire session
                      autopair-dont-activate t
                      multi-term-program "/bin/bash")
                (define-key term-raw-map (kbd "C-y") 'esc-term-paste)
                (define-key esc-mode-map (kbd "C-c T") 'ansi-term)
                (define-key esc-mode-map (kbd "C-c t") 'ansi-term-next))))
#+END_SRC

** Eshell config
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'eshell-named-command-hook 'esc/eshell-exec-perl)
  (add-hook 'eshell-mode-hook
            (lambda ()
              (define-key eshell-mode-map (kbd "C-x C-p")
                'eshell-previous-matching-input-from-input)
              (define-key eshell-mode-map (kbd "C-x C-n")
                'eshell-next-matching-input-from-input)
              (when (require 'em-smart nil 'noerror)
                (setq eshell-where-to-jump 'begin
                      eshell-review-quick-commands nil
                      eshell-smart-space-goes-to-end t))))
#+END_SRC

** w3m config
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload-from-package "w3m"
    '(w3m
      w3m-copy-buffer))

  (autoload-from-package "w3m-config"
    '(w3m-go-to-linknum
      w3m-first-or-subsequent-google-result
      w3m-prev-google-result
      w3m-find-a-google-result
      w3m-filter-all
      w3m-new-tab
      w3m-browse-url-new-tab
      w3m-wiki-new-tab
      w3m-google-new-tab
      w3m-browse-current-buffer))

  (add-hook 'w3m-mode-hook
            (lambda ()
              (define-key w3m-mode-map "n" 'w3m-first-or-subsequent-google-result)
              (define-key w3m-mode-map "p" 'w3m-prev-google-result)

              (define-key w3m-mode-map "."
                (lambda() (interactive) (scroll-down 6)))

              (define-key w3m-mode-map ","
                (lambda() (interactive) (scroll-up 6)))

              (define-key w3m-mode-map "C-."
                (lambda() (interactive) (scroll-right 3)))

              (define-key w3m-mode-map "C-,"
                (lambda() (interactive) (scroll-left 3)))

              ;; Eliminate tailing whitespace for a friendlier C-e
              (add-hook 'w3m-display-hook
                        (lambda (url)
                          (let ((buffer-read-only nil))
                            (delete-trailing-whitespace))))))
#+END_SRC
** Ido config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'ido
    (setq ido-everywhere t                             ;always Ido
          ido-enable-flex-matching t                   ;smarter Ido
          ido-create-new-buffer 'always                ;quieter Ido
          ido-file-extensions-order '(".org" ".txt"))) ;precedence

  (autoload-from-package "ido-extras"
    '(ido-recentf-open
      ido-goto-symbol))
#+END_SRC

** Iedit config
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'iedit-mode-hook 'esc/iedit-mode-hook)
#+END_SRC

** Git gutter+ config
#+NAME: Git gutter+ config
#+BEGIN_SRC emacs-lisp :tangle yes
  ;(global-git-gutter+-mode t)
  (after 'git-gutter+
    ;;; Jump between hunks
    (define-key git-gutter+-mode-map (kbd "C-x n") 'git-gutter+-next-hunk)
    (define-key git-gutter+-mode-map (kbd "C-x p") 'git-gutter+-previous-hunk)
     ;;; Act on hunks
    (define-key git-gutter+-mode-map (kbd "C-x v =") 'git-gutter+-show-hunk)
    ;; (define-key git-gutter+-mode-map (kbd "C-x r") nil) ;; stupid
    ;; Stage hunk at point.
    ;; If region is active, stage all hunk lines within the region.
    (define-key git-gutter+-mode-map (kbd "C-x s") 'git-gutter+-stage-hunks)
    (define-key git-gutter+-mode-map (kbd "C-x c") 'git-gutter+-commit)
    (define-key git-gutter+-mode-map (kbd "C-x C") 'git-gutter+-stage-and-commit))
#+END_SRC

** Multiple cursors
#+NAME: Multiple cursors autoloads
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'multiple-cursors-autoloads
    (setq mc/list-file "~/.emacs.d/meta/.mc-lists.el")
    (add-hook 'multiple-cursors-mode-enabled-hook  'esc/multiple-cursors-mode-enabled-hook)
    (add-hook 'multiple-cursors-mode-disabled-hook 'esc/multiple-cursors-mode-disabled-hook))
#+END_SRC
** Ace jump config
#+NAME: Ace-jump mode config
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'ace-jump-mode
      (ace-jump-mode-enable-mark-sync))

  (after 'ace-window
       (setq aw-keys '(?a ?b ?c ?d ?e ?f ?g ?h ?i)))
#+END_SRC

** Save hooks

Handy little hooks that nudge new files in the right direction.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
** Which func config
#+NAME: which-func configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'which-func
    (mapc (lambda (mode) (add-to-list 'which-func-modes mode))
          '(org-mode
            emacs-lisp-mode
            c-mode
            c++-mode
            java-mode
            ruby-mode
            enh-ruby-mode)))
#+END_SRC

** comint-mode-hook

Some esc-keys weren't mapped with shell use in mind. Here's a bandaid.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'comint-mode-hook 'esc/comint-mode-hook)
#+END_SRC

** Midnight mode config
#+NAME: midnight-mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'midnight                        ;clean stale buffers
    (midnight-delay-set 'midnight-delay "5:00am"))
    #+END_SRC

** Keyfreq mode config
#+NAME: keyfreq-mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'keyfreq                               ;let's take some stats
    (keyfreq-autosave-mode 1)
    (setq keyfreq-file "~/.emacs.d/meta/keyfreq"))
#+END_SRC

** Browse kill ring config
#+NAME: browse-kill-ring configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'browse-kill-ring
    (browse-kill-ring-default-keybindings))
#+END_SRC

** Mouse avoidance config
#+NAME: mouse-avoidance mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (mouse-avoidance-mode 'exile)
#+END_SRC

** El-Doc mode config
#+NAME: eldoc configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'eldoc
    (after 'diminish (diminish 'eldoc-mode))
    (add-hook 'emacs-lisp-mode-hook (lambda() (turn-on-eldoc-mode))))
#+END_SRC

#+NAME: eldoc for c configuration
#+BEGIN_SRC emacs-lisp :tangle no
  (setq c-eldoc-includes "`pkg-config gtk+-2.0 --cflags` -I./ -I../ ")
  (load "c-eldoc")
  (add-hook 'c-mode-hook 'c-turn-on-eldoc-mode)
#+END_SRC

** Bury compilation buffer
#+NAME: Burying the Compilation buffer if successful
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'compilation-finish-functions
            'esc/bury-compilation-buffer-if-successful)
  (add-to-list 'same-window-buffer-names "*compilation*")
#+END_SRC
** Hippie expand config
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice he-substitute-string (after he-paredit-fix)
    "Remove extra paren when expanding line in paredit"
    (when (and (fboundp 'paredit-mode)
               paredit-mode (equal (substring str -1) ")"))
      (backward-delete-char 1)
      (forward-char)))
#+END_SRC
** Bitly configuration
#+NAME: bitly oauth token
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'bitly
    (setq bitly-access-token "b4a5cd4e51df442ab97012cfc2764c599d6eabf8"))
#+END_SRC
** Paradox configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq paradox-github-token "37204ef66b6566274616d130ec61a0cd4f98e066")
#+END_SRC
** Big fringe mode hook
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'big-fringe-mode-hook 'esc/big-fringe-mode-hook)
   #+END_SRC
** Haskell mode hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'haskell-mode-hook 'haskell-indent-mode)
#+END_SRC
** Pretty lambdada mode hook
#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc (lambda (prettify-this-mode)
          (add-hook prettify-this-mode 'pretty-lambda))
        '(emacs-lisp-mode-hook
          org-mode-hook ;to include source blocks :\
          enh-ruby-mode-hook
          ruby-mode-hook))
#+END_SRC
** Kill emacs hook

Summon the magical cookies.

#+NAME: black magic -- begin!
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'kill-emacs-hook 'update-esc-lisp-autoloads)
#+END_SRC

Override the kill function.

#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'save-buffers-kill-emacs 'esc/save-buffers-kill-emacs)
#+END_SRC

* OS configuration

Operating system-specific configurations take place here, within this
massive =cond=.

#+NAME: Operating System specific configurations
#+BEGIN_SRC emacs-lisp :tangle yes
  (cond ((or (eq system-type 'ms-dos)
             (eq system-type 'windows-nt)
             (eq system-type 'cygwin))

         ;; Windows config
         (message-progress "Loading Windows specific configuration..."
           (setq w32-pass-lwindow-to-system nil
                 w32-pass-rwindow-to-system nil
                 w32-pass-apps-to-system nil
                 w32-lwindow-modifier 'super ; Left Windows key
                 w32-rwindow-modifier 'super ; Right Windows key
                 w32-apps-modifier 'hyper)   ; Menu key
           (require-package '(w32-symlinks))
#+END_SRC

Note: for GNU Emacs compiled for Microsoft, both of the below options
need to be set in order to follow symlinks. The shell snippet tells
cygwin to create symlinks in a friendly format (old links need to be
regenerated with this flag) and the sexp is loaded by Emacs allowing
transparent use of symlinks.

#+BEGIN_SRC sh :tangle no
  # TODO: tangle me
  export CYGWIN="nodosfilewarning winsymlinks"
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (customize-option 'w32-symlinks-handle-shortcuts)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
           ))
#+END_SRC

Begin Mac OS configuration

#+BEGIN_SRC emacs-lisp :tangle yes
         ((or (eq system-type 'darwin))
          (message-progress "Loading Darwin specific configuration..."
            (setq mac-command-modifier 'meta)
            (setq mac-option-modifier 'super)
            (setq ns-function-modifier 'hyper))))
#+END_SRC

* Dired configuration

TODO: reduce this kludge
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'dired-details)
  (dired-details-install)
#+END_SRC

#+NAME: dired configuration
#+BEGIN_SRC emacs-lisp :tangle yes
    ;; auto-dired-reload
    ;; Reload dired after making changes
    (after 'dash
      (put '--each 'lisp-indent-function 1)
      (--each '(dired-do-rename
                  dired-create-directory
                  wdired-abort-changes)
          (eval `(defadvice ,it (after revert-buffer activate)
                   (revert-buffer)))))
    ;; end auto-dired-reload- thanks Magnar

  (add-hook 'dired-mode-hook 'esc/dired-mode-hook)
  (add-hook 'dired-load-hook 'esc/dired-load-hook)
#+END_SRC

** Wdired
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-after-load "wdired"
    '(progn
       (define-key wdired-mode-map (kbd "C-a") 'esc/dired-back-to-start-of-files)
       (define-key wdired-mode-map
         (vector 'remap 'beginning-of-buffer) 'esc/dired-back-to-top)
       (define-key wdired-mode-map
         (vector 'remap 'end-of-buffer) 'esc/dired-jump-to-bottom)))
#+END_SRC

* Colors

Initialize the color-theme-stack

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar color-theme-stack nil "Stack of color themes.")
#+END_SRC

Lay the color-theme-stack api

#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/color-theme-stack.el
  ;;;###autoload
  (defun color-theme-push ()
    "Switch to a theme, saving the old one."
    (push (color-theme-make-snapshot) color-theme-stack)
    (message "Color theme pushed"))
 ;;;###autoload
  (defun color-theme-pop ()
    "Restore the previous theme in use."
    (funcall (pop color-theme-stack))
    (message "Color theme popped"))
#+END_SRC

[[http://2.media.bustedtees.cvcdn.com/e/-/bustedtees.09c737ee-d77b-45da-ac5c-b9bbb562.gif][Powerâš¡Line]]

#+BEGIN_SRC emacs-lisp :tangle yes
  (powerline-default-theme)
#+END_SRC

** Color theme tweaks
*** Wombat
Properly colorize wombat.

#+BEGIN_SRC emacs-lisp :tangle yes
  (set-face-attribute 'highlight nil :foreground 'unspecified :underline nil)
  (set-face-attribute 'region nil :foreground 'unspecified :underline nil :background "#666")
#+END_SRC

* Organize mode configuration
** org config
My favorite mode. This was the reason I started using Emacs, didja know?
#+NAME: org mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default major-mode 'org-mode)  ;default mode for new buffers
  (setq org-replace-disputed-keys t    ;must be set before org is loaded
        org-clock-persist 'history
        org-hide-leading-stars t
        org-hide-emphasis-markers t
        org-hierarchical-todo-statistics     nil
        org-checkbox-hierarchical-statistics nil
        org-src-fontify-natively t
        org-directory "~/org"
        org-agenda-files (append '("~/org/todo.org")))

  (after 'org
    ;; TODO: maybe put these defuns somewhere
    (defun esc/add-imenu-to-menubar ()
      (imenu-add-to-menubar "Imenu"))
    (add-hook 'org-mode-hook 'esc/add-imenu-to-menubar)

    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 55)
    (defun esc/after-org-mode-hook ()
      (org-indent-mode)
      (local-set-key (kbd "C-M-n") 'outline-next-visible-heading)
      (local-set-key (kbd "C-M-p") 'outline-previous-visible-heading)
      (local-set-key (kbd "C-c C-a") 'org-todo))
    (add-hook 'org-mode-hook 'esc/after-org-mode-hook))
#+END_SRC

#+NAME: adding comments to org
#+BEGIN_SRC emacs-lisp :tangle yes
  (after 'org
         (add-to-list 'org-structure-template-alist
                      '("E"
                        "#+BEGIN_SRC emacs-lisp ?\n\n#+END_SRC"
                        "<emacs-lisp>\n?\n</emacs-lisp>")))
#+END_SRC

** org babel
#+NAME: whitelist org-babel execute permission
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'org-mode-hook
            (lambda ()
              (setq org-confirm-babel-evaluate nil)

              (org-babel-do-load-languages
               'org-babel-load-languages
               '(;; Always execute these languages
                 (R               .       t)
                 (ditaa           .       t)
                 (dot             .       t)
                 (plantuml        .       t)
                 (emacs-lisp      .       t)
                 (lisp            .       t)
                 (clojure         .       t)
                 (scala           .       t)
                 (gnuplot         .       t)
                 (haskell         .       t)
                 (ocaml           .       t)
                 (python          .       t)
                 (ruby            .       t)
                 (sh              .       t)
                 (sqlite          .       t)
                 (octave          .       t)
                 (plantuml        .       t)
                 ;; Never execute these languages
                 (screen          .       nil)
                 (sql             .       nil)))))
#+END_SRC

[[http://lists.gnu.org/archive/html/emacs-orgmode/2012-05/msg00708.html][More information on defining your own Easy Templates]].

#+NAME: custom babel Easy Templates
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'org-structure-template-alist
          '("E"
            "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"
            "<src lang=\"emacs-lisp\">\n\n</src>"))
#+END_SRC

#+NAME: org support for plantuml
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; org-export-blocks-format-plantuml.el Export UML using plantuml
  ;;
  ;; OBSOLETED, use ob-plantuml.el bundled in org instead.
  ;;
  ;; Copy from org-export-blocks-format-ditaa
  ;;
  ;; E.g.
  ;; #+BEGIN_UML
  ;;   Alice -> Bob: Authentication Request
  ;;   Bob --> Alice: Authentication Response
  ;; #+END_UML

  (eval-after-load "org-exp-blocks"
    '(progn
       (add-to-list 'org-export-blocks '(uml iy/org-export-blocks-format-plantuml nil))
       (add-to-list 'org-protecting-blocks "uml")))

  (defvar iy/org-plantuml-jar-path (expand-file-name "~/Dropbox/java-libs/plantuml.jar")
    "Path to the plantuml jar executable.")
  (defun iy/org-export-blocks-format-plantuml (body &rest headers)
    "Pass block BODY to the plantuml utility creating an image.
    Specify the path at which the image should be saved as the first
    element of headers, any additional elements of headers will be
    passed to the plantuml utility as command line arguments."
    (message "plantuml-formatting...")
    (let* ((args (if (cdr headers) (mapconcat 'identity (cdr headers) " ")))
           (data-file (make-temp-file "org-plantuml"))
           (hash (progn
                   (set-text-properties 0 (length body) nil body)
                   (sha1 (prin1-to-string (list body args)))))
           (raw-out-file (if headers (car headers)))
           (out-file-parts (if (string-match "\\(.+\\)\\.\\([^\\.]+\\)$" raw-out-file)
                               (cons (match-string 1 raw-out-file)
                                     (match-string 2 raw-out-file))
                             (cons raw-out-file "png")))
           (out-file (concat (car out-file-parts) "_" hash "." (cdr out-file-parts))))
      (unless (file-exists-p iy/org-plantuml-jar-path)
        (error (format "Could not find plantuml.jar at %s" iy/org-plantuml-jar-path)))
      (setq body (if (string-match "^\\([^:\\|:[^ ]\\)" body)
                     body
                   (mapconcat (lambda (x) (substring x (if (> (length x) 1) 2 1)))
                              (org-split-string body "\n")
                              "\n")))
      (cond
       ((or htmlp latexp docbookp)
        (unless (file-exists-p out-file)
          (mapc ;; remove old hashed versions of this file
           (lambda (file)
             (when (and (string-match (concat (regexp-quote (car out-file-parts))
                                              "_\\([[:alnum:]]+\\)\\."
                                              (regexp-quote (cdr out-file-parts)))
                                      file)
                        (= (length (match-string 1 out-file)) 40))
               (delete-file (expand-file-name file
                                              (file-name-directory out-file)))))
           (directory-files (or (file-name-directory out-file)
                                default-directory)))
          (with-temp-file data-file (insert (concat "@startuml\n" body "\n@enduml")))
          (message (concat "java -jar " iy/org-plantuml-jar-path " -pipe " args))
          (with-temp-buffer
            (call-process-shell-command
             (concat "java -jar " iy/org-plantuml-jar-path " -pipe " args)
             data-file
             '(t nil))
            (write-region nil nil out-file)))
        (format "\n[[file:%s]]\n" out-file))
       (t (concat
           "\n#+BEGIN_EXAMPLE\n"
           body (if (string-match "\n$" body) "" "\n")
           "#+END_EXAMPLE\n")))))

#+END_SRC

#+NAME: org latex export syntax highlighting
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Include the latex-exporter
  (require 'ox-latex nil 'noerror)
  ;; Add minted to the defaults packages to include when exporting.
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  ;; Tell the latex export to use the minted package for source
  ;; code coloration.
  (setq org-latex-listings 'minted)
  ;; Let the exporter use the -shell-escape option to let latex
  ;; execute external programs.
  ;; This obviously and can be dangerous to activate!
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

** org beamer

Thanks to [[http://emacs-fu.blogspot.com/2009/10/writing-presentations-with-org-mode-and.html][emacs-fu]]!

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; allow for export=>beamer by placing

  ;; #+LaTeX_CLASS: beamer in org files
  (unless (boundp 'org-export-latex-classes)
    (setq org-export-latex-classes nil))
  (add-to-list 'org-export-latex-classes
    ;; beamer class, for presentations
    '("beamer"
       "\\documentclass[11pt]{beamer}\n
        \\mode<{{{beamermode}}}>\n
        \\usetheme{{{{beamertheme}}}}\n
        \\usecolortheme{{{{beamercolortheme}}}}\n
        \\beamertemplateballitem\n
        \\setbeameroption{show notes}
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{hyperref}\n
        \\usepackage{color}
        \\usepackage{listings}
        \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
    frame=single,
    basicstyle=\\small,
    showspaces=false,showstringspaces=false,
    showtabs=false,
    keywordstyle=\\color{blue}\\bfseries,
    commentstyle=\\color{red},
    }\n
        \\usepackage{verbatim}\n
        \\institute{{{{beamerinstitute}}}}\n
         \\subject{{{{beamersubject}}}}\n"

       ("\\section{%s}" . "\\section*{%s}")

       ("\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}"
         "\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}")))

    ;; letter class, for formal letters

    (add-to-list 'org-export-latex-classes

    '("letter"
       "\\documentclass[11pt]{letter}\n
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{color}"

       ("\\section{%s}" . "\\section*{%s}")
       ("\\subsection{%s}" . "\\subsection*{%s}")
       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
       ("\\paragraph{%s}" . "\\paragraph*{%s}")
       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

#+END_SRC
** org capture
#+NAME: set org capture path
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-default-notes-file (concat org-directory "/capture.org"))
  (after 'org
    (after 'esc-mode
      (esc-key "C-c C-p" 'org-capture)))
#+END_SRC

#+NAME org capture templates
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-capture-templates
        '(;; General tasks go here
          ("t" "Todo" entry
           (file+headline (concat org-directory "/todo.org") "Tasks")
           "* TODO %?\n  %a")
          ;; Used to record my state
          ("j" "Journal" entry
           (file+datetree (concat org-directory "/journal.org"))
           "* %?\nEntered on %U\n  %i\n  %a")

          ;;; Work-related captures
          ("c" "Centaur" entry
           (file+datetree (concat org-directory "/centtech/centtech.org"))
           "* TODO %?\n  %i\n  %a")

          ;;; Personal captures
          ;; Notes about Super Smash Bros. 64
          ("s" "Smash Bros." entry
           (file+headline (concat org-directory "/smash/smash.org") "Notes")
           "* %?\n")))
#+END_SRC

*** org refile
#+NAME: org refile locations
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ;; Work refile locations
   esc-refile-targets-centtech
   `(,(concat org-directory "/centtech/lru.org")
     ,(concat org-directory "/centtech/pse.org")
     ,(concat org-directory "/centtech/newreg.org"))

   ;; Personal refile locations
   esc-refile-targets-smash
   `(,(concat org-directory "/smash/64.org")
     ,(concat org-directory "/smash/melee.org")
     ,(concat org-directory "/smash/pm.org"))

   org-refile-targets '((nil                         :maxlevel . 5)
                        (esc-refile-targets-centtech :maxlevel . 5)
                        (esc-refile-targets-smash    :maxlevel . 5)
                        (org-agenda-files            :maxlevel . 4)))
#+END_SRC

* Personal keybinding mode
** summary
Here lies my personal minor mode, where I confine all of my custom
keybindings. I also hook all of my preferred major and minor modes
onto this mode's activation hook. Though all of my customizations are
active by default for new emacs sessions, one can get back to the
default settings by running =M-x esc-mode=.

** esc variables

As a convention, esc functions are prefixed with `esc/' while esc
variables are prefixed with `esc-'

#+NAME: define customizable variables
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defcustom esc-line-shift-amount 6
      "The number of lines to shift in `esc-mode-map'."
      :type    'integer
      :options '(5 6)
      :group   'esc-mode)
#+END_SRC
#+NAME: define internal variables
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defvar esc-mode-map (make-keymap)
      "The keymap for \\[esc-mode].")
#+END_SRC
#+NAME: define minor mode
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (define-minor-mode esc-mode
      "Toggle esc-keys mode.
                   A minor mode so that my key settings override annoying major modes."
      t " esc" 'esc-mode-map)
#+END_SRC
#+NAME: define minor mode hook
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  ;; TODO: devise method of keeping these options in sync with the entire current implementation of esc/accompanying-mode-hook
  (defcustom esc/accompanying-mode-hook nil
    "Hook that is appended to esc-mode-hook."
    :type         'hook
    :options      '(;; do's
                    (when (fboundp 'ido-mode) (ido-mode (esc-mode-enabledp)))
                    (when (fboundp 'eldoc-mode) (eldoc-mode (esc-mode-enabledp)))
                    (when (fboundp 'winner-mode) (winner-mode (esc-mode-enabledp)))
                    (when (fboundp 'keyfreq-mode) (keyfreq-mode (esc-mode-enabledp)))
                    (when (fboundp 'recentf-mode) (recentf-mode (esc-mode-enabledp)))
                    (when (fboundp 'icomplete-mode) (icomplete-mode (esc-mode-enabledp)))
                    (when (fboundp 'guide-key-mode) (guide-key-mode (esc-mode-enabledp)))
                    (when (fboundp 'auto-fill-mode) (auto-fill-mode (esc-mode-enabledp)))
                    (when (fboundp 'show-paren-mode) (show-paren-mode (esc-mode-enabledp)))
                    (when (fboundp 'line-number-mode) (line-number-mode (esc-mode-enabledp)))
                    (when (fboundp 'display-time-mode) (display-time-mode (esc-mode-enabledp)))
                    (when (fboundp 'column-number-mode) (column-number-mode (esc-mode-enabledp)))
                    (when (fboundp 'which-function-mode) (which-function-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-hl-line-mode) (global-hl-line-mode (esc-mode-enabledp)))
                    (when (fboundp 'display-battery-mode) (display-battery-mode (esc-mode-enabledp)))
                    (when (fboundp 'autopair-global-mode) (autopair-global-mode (esc-mode-enabledp)))
                    (when (fboundp 'auto-compression-mode) (auto-compression-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-on-screen-mode) (global-on-screen-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-font-lock-mode) (global-font-lock-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-auto-revert-mode) (global-auto-revert-mode (esc-mode-enabledp)))
                    (when (fboundp 'global-rainbow-delimiters-mode) (global-rainbow-delimiters-mode (esc-mode-enabledp)))
                    ;; dont's
                    (when (fboundp 'tool-bar-mode) (tool-bar-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'menu-bar-mode) (menu-bar-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'scroll-bar-mode) (scroll-bar-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'blink-cursor-mode) (blink-cursor-mode (dont (esc-mode-enabledp))))
                    (when (fboundp 'transient-mark-mode) (transient-mark-mode (dont (esc-mode-enabledp)))))
    :group        'esc-mode)
#+END_SRC

** esc macros
#+NAME: self inflection
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defmacro esc-mode-enabledp ()
      "A macro to determine if \\[esc-mode] is currently enabled."
      `(progn (and (boundp 'esc-mode) esc-mode)))
#+END_SRC
Wait, is this even being used??
#+NAME: add-or-remove-hook
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
    (defmacro add-or-remove-hook (hook function)
      "A macro to add a HOOK to FUNCTION, if `esc-mode' is being enabled;
              or remove a HOOK from FUNCTION, if `esc-mode' is being disabled."
      `(progn (if (esc-mode-enabledp)
                  (add-hook ,hook ,function)
                (remove-hook ,hook ,function))))
#+END_SRC
#+NAME: diminish-or-restore
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
    (after 'diminish-autoloads
      (defmacro diminish-or-restore (mode)
        "A macro to diminish a MODE, if `esc-mode' is being enabled;
              or disable a MODE, if `esc-mode' is being disabled."
        `(progn
           (after 'diminish-autoloads
             (if (esc-mode-enabledp)
                 (diminish ,mode)
               (diminish-undo ,mode))))))
#+END_SRC
#+NAME: never you mind these macros
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (defmacro dont (operand)
    "A macro to avoid awkward, unintuitive code in \\[esc-accompanying-mode-hook].
            OPERAND is an integer to de/activate a given mode."
    `(progn
       (if (numberp ,operand)
           (* (- 1) ,operand)
         (if ,operand nil t))))
#+END_SRC
#+NAME: macros to insert bindings in esc-mode-map
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
    (defmacro esc-key (sequence action)
      "A macro to bind SEQUENCE to ACTION in `esc-mode-map'."
      `(define-key esc-mode-map (kbd ,sequence) ,action))

    (defmacro esc-keys (&rest binding-list)
      "A macro to bind all keybindings and functions in BINDING-LIST
    in `esc-mode-map'.

    This macro runs conses through \\[esc-key] for convenience."
      (declare (indent defun))
      `(mapc (lambda (binding) (esc-key (car binding) (cdr binding)))
             '(,@binding-list)))
#+END_SRC
** esc bindings
#+NAME: keybindings defined here
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  ;; Enhanced buffer movement (not point movement)
  (esc-keys
    ("C-," . esc/scroll-up-slight)
    ("C-." . esc/scroll-down-slight))

  ;; Enhanced keybindings
  (esc-keys
    ("C-'"     . execute-extended-command)
    ("M-g"     . esc/goto-line-with-feedback)
    ("C-j"     . newline-and-indent) ;for consistency in *scratch*
    ("C-a"     . esc/back-to-indentation-or-beginning)
    ("s-z"     . other-window)
    ("C-x 4 k" . esc/mode-line-other-buffer-other-window)
    ("C-x 4 9" . esc/bury-buffer-delete-window)
    ("M-x"     . execute-extended-command)
    ("C-'"     . query-replace)
    ("C-x M-r" . revert-buffer-no-confirm)
    ("C-x 2"   . esc/vsplit-last-buffer)
    ("C-x 3"   . esc/hsplit-last-buffer)
    ("M-s o"   . occur-dwim))

  ;; Search for current word up or down from point
  (esc-keys
    ("<M-down>" . esc/search-word-forward)
    ("<M-up>" . esc/search-word-backward))

  ;; Equivalent to middle-click yank on mouse
  (esc-key "C-c y" 'esc/middle-click-yank)

  ;; Windmove from shift keys
  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))

  ;; Window adjustment
  (esc-keys
    ("C-c ["   . esc/rotate-window-split)
    ("C-c ]"   . esc/swap-buffer-locations)
    ;; TODO: rename defun
    ("C-M-c [" . esc/should-have-opened-this-in-other-window)
    ("C-M-c ]" . esc/toggle-window-selectability))

  ;; Org mode keybindings
  (after 'org
    (define-key org-mode-map (kbd "C-c n") 'esc/org-next-source-code-block)
    (define-key org-mode-map (kbd "C-c p") 'esc/org-prev-source-code-block))

  ;; Miscellaneous keybindings
  (esc-keys
    ("C-c a"   . org-agenda)
    ("M-K"     . kill-sentence)
    ("M-Z"     . zap-up-to-char) ; up-to, life saver
    ("M-j"     . just-one-space) ; conflicts with spotlight
    ("C-c k"   . esc/copy-line)
    ("<f6>"    . spray-mode)
    ("C-S-l"   . esc/toggle-letter-case)
    ("M-P"     . align-regexp)
    ("C-c e"   . esc/eval-and-replace)
    ("C-c C-b" . mode-line-other-buffer)
    ;; TODO: change sexp wrapping (i.e. {}[]()) from Xah Lee
    )

  ;; f-related-keybindings
  (esc-keys
    ("C-x F"   . recentf-open-files)
    ("C-x f"   . esc/toggle-selective-display)
    ("C-x M-f" . single/ff-in-single-mode))

  ;; Fold-this keybindings. Thanks again [[https://github.com/magnars/fold-this.el][Magnar]]!
  (esc-keys
    ("C-c f"   . fold-this)
    ("C-c F"   . fold-this-unfold-all))

  ;; ido-extras keybindings
  (esc-keys
    ("M-i"       . ido-goto-symbol)
    ("C-x C-r"   . ido-recentf-open)
    ("C-x C-S-r" . find-file-read-only))

  ;; Programming bindings
  (esc-keys
    ("C-c m" . compile)
    ("C-c C-m" . recompile))

  ;; C-q cluster
  (esc-keys
    ("C-q"     . delete-region)  ;like C-w, but gone
    ("C-c q"   . auto-fill-mode) ;more frequented than
    ("C-c C-q" . quoted-insert))   ;this command


  ;; w3m bindings
  (after 'w3m-autoloads
    (esc-keys
      ("C-x j"   . w3m-google-new-tab)
      ("C-x J"   . w3m-wiki-new-tab)
      ("C-x C-m" . w3m-browse-url)))

  ;; Text movement
  (after 'move-text-autoloads
    (esc-keys
      ("<C-S-up>"     . move-text-up)
      ("<C-S-down>"   . move-text-down)
      ("<C-return>"   . esc/open-line-below)
      ("<C-S-return>" . esc/open-line-above)))

  ;; LaTeX bindings
  (esc-key "C-c l b" 'esc/insert-latex-block)

  ;; Minimap bindings
  (esc-key "C-c M-m" 'esc/minimap-toggle)

  ;; Ace jump mode. Like an ace
  (after 'ace-jump-mode-autoloads
    (esc-keys
      ("C-c SPC" . ace-jump-mode)
      ("C-x SPC" . ace-jump-mode-pop-mark)))

  ;; Ace jump buffer, nice in a pinch
  (after 'ace-jump-buffer
    (esc-key "C-M-S-l" 'ace-jump-buffer))

  ;; Ace window. Genius!
  (after 'ace-window
     (esc-key "C-M-o" 'ace-window)
     ;; how unfriendly! This replaces \\[split-line].
     (esc-key "C-M-O" 'split-line))

  ;; Mark commands
  (esc-keys
    ("C-x m" . pop-to-mark-command))

  ;; Hide-lines bindings
  (after 'hide-lines-autoloads
    (esc-key "C-c h" 'hide-lines)
    (esc-key "C-c M-h" 'esc/reveal-all-hidden-lines))

  (esc-key "C-;" 'comment-dwim)

  (after 'multiple-cursors-autoloads
    (esc-keys
      ("C-S-c C-S-c" . mc/edit-lines)
      ("C->" . mc/mark-next-like-this)
      ("C-<" . mc/mark-previous-like-this)
      ("C-c !" . mc/sort-regions)    ;1
      ("C-c @" . mc/reverse-regions) ;2
      ("C-c #" . mc/insert-numbers)  ;3
      ("C-c *" . mc/mark-all-like-this)
      ("C-c C-*" . mc/mark-all-like-this-dwim)))

  ;; Lisp/sexp movement
  (esc-keys
    ("C-S-k"    . kill-sexp)
    ("C-c l \\" . li/indent-entire-defun)
    ("C-s-e"    . li/eval-current-defun)
    ("C-c l e"  . li/eval-current-sexp))
  ;; Preserving stock org functionality
  (esc-key "C-c l l" 'org-store-link)

  ;; single-mode != vi
  (esc-keys
    ("C-c l s"  . single-mode)
    ("<escape>" . single-mode))

  ;; Buffer control
  (esc-keys
    ;("C-x C-b" . ibuffer)              ; use font-lock with buffer lists
    ;TODO: replace this with something ok (was just using this at the time of )
    ; editing and didn't know what to use this key for
    ("C-x C-b" . global-git-gutter+-mode) ; every invocation was accidental
    ("C-x M-b" . bury-buffer)
    ("C-x M-B" . esc/bury-other-buffer)
    ("C-c o"   . clone-indirect-buffer-other-window)
    ("C-c C-o" . ff-find-other-file)
    ("C-o"     . ace-window))

  (after 'expand-region-autoloads      ;Three guesses [[https://github.com/magnars/expand-region.el][who]]
    (esc-key "C-=" 'er/expand-region)) ;wrote this package

  ;; Help+
  (esc-keys
    ("C-h C-f"   . find-function)
    ("C-h C-k"   . find-function-on-key)
    ("C-h C-v"   . find-variable)
    ("C-h C-l"   . find-library)
    ("C-h C-n"   . esc/insert-defun-at-point)
    ("C-h M-k"   . describe-keymap)
    ("C-h C-M-c" . esc/insert-key-combination))

  ;; Un- and re- doing
  (esc-keys
    ("C-c /"   . goto-last-change))

  ;; Font maniplation
  (esc-keys
    ("C-M-<" . esc/zoom-out)
    ("C-M->" . esc/zoom-in))

  ;;; Function keys
  (esc-key "<f7>" 'scroll-all-mode)
  (esc-key "<f8>" 'follow-delete-other-windows-and-split)
  (esc-key "<f9>" 'flyspell-buffer)

  ;; Helm
  (after 'helm-autoloads
    (esc-keys
      ("M-s-x"   . helm-M-x)
      ("C-c i"   . helm-imenu)
      ("C-x C-j" . helm-for-files)))

  ;; Sysadmin bindings
  (esc-keys
    ("C-M-+"     . esc/search-my-lisp-dir)
    ("C-c C-i"   . esc/edit-my-emacs)
    ("C-c C-M-i" . esc/edit-my-bash))

  ;; esc delimeter and line hacks
  (esc-keys
    ("C-<backspace>" . esc/backward-kill-line)
    ("M-k"   . esc/pull-up-line)
    ("C-M--" . esc/insert-little-arrow)
    ("C-M-j" . esc/insert-surrounding-parens)
    ("C-M-k" . esc/insert-surrounding-braces)
    ("C-M-|" . esc/insert-surrounding-pipes)
    ("C-M-l" . esc/insert-surrounding-brackets)
    ("C-M-;" . esc/insert-surrounding-brackets-with-colon)
    ("C-M-," . esc/insert-surrounding-chevrons)
    ("C-M-'" . esc/insert-surrounding-quotes)
    ("C-M-*" . esc/insert-surrounding-stars)
    ("C-M-g" . esc/insert-surrounding-dollars)
    ("C-M-`" . esc/insert-surrounding-ticks))

  ;; programming delimeter and line hacks
  (esc-keys
    ("M-'"   . toggle-quotes))

  ;; Buffer-overlay hacks: super useful!
  (esc-keys
   ("s-e" . esc/raise-eshell)
   ("s-s" . esc/raise-ansi-term)
   ("s-q" . esc/raise-magit-status))
#+END_SRC

I don't know where smartrep defines keys but this worked for me and I
haven't had to look at it yet.

#+BEGIN_SRC emacs-lisp :tangle no
  (smartrep-define-key global-map "C-c ."
    '(("+" . apply-operation-to-number-at-point)
      ("-" . apply-operation-to-number-at-point)
      ("*" . apply-operation-to-number-at-point)
      ("/" . apply-operation-to-number-at-point)
      ("\\" . apply-operation-to-number-at-point)
      ("^" . apply-operation-to-number-at-point)
      ("<" . apply-operation-to-number-at-point)
      (">" . apply-operation-to-number-at-point)
      ("#" . apply-operation-to-number-at-point)
      ("%" . apply-operation-to-number-at-point)
      ("'" . operate-on-number-at-point)))
#+END_SRC

** esc hydras
TODO: determine how to integrate these into esc-mode-map

#+NAME: Change buffer text size
#+BEGIN_SRC emacs-lisp :tangle yes
  (hydra-create "<f2>"
    '(("k" text-scale-increase)
      ("j" text-scale-decrease)))
#+END_SRC

#+NAME: Change global text size
#+BEGIN_SRC emacs-lisp :tangle yes
  (hydra-create "C-M-<"
    '(("," esc/zoom-out)
      ("." esc/zoom-in)))
#+END_SRC

#+NAME: Navigate compile warnings
#+BEGIN_SRC emacs-lisp :tangle yes
  (hydra-create "C-`"
    '(("h" first-error "first")
      ("j" next-error "next")
      ("k" previous-error "prev")))
#+END_SRC

** esc hook
#+NAME: esc-mode-hook
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  ;; The proper definition of `esc-mode-hook'
  (defun esc/accompanying-mode-hook ()
    "esc's customizations added to \\[esc-mode-hook]."
    (let ((activate-bool (esc-mode-enabledp)))
      (setq activate (if activate-bool 1 -1))
      ;; esc-mode wouldn't be complete without these helper modes

      ;; activate these modes
      (mapc (lambda (mode) (when (fboundp mode)
                               (ignore-errors (funcall mode activate))))
            '(ido-mode
              eldoc-mode
              winner-mode
              keyfreq-mode
              recentf-mode
              icomplete-mode
              guide-key-mode
              auto-fill-mode
              show-paren-mode
              line-number-mode
              display-time-mode
              column-number-mode
              which-function-mode
              global-hl-line-mode
              display-battery-mode
              autopair-global-mode
              auto-compression-mode
              global-on-screen-mode
              global-font-lock-mode
              global-auto-revert-mode
              global-rainbow-delimiters-mode))

      ;; deactivate these modes
      (mapc (lambda (mode) (when (fboundp mode)
                               (funcall mode (dont activate))))
            '(tool-bar-mode
              menu-bar-mode
              scroll-bar-mode
              blink-cursor-mode
              transient-mark-mode))

      ;; esc-mode enjoys these settings also
      (when (fboundp 'global-git-gutter-mode)
        (global-git-gutter-mode activate-bool))
      (setq-default save-place       activate-bool
                    abbrev-mode      activate-bool
                    auto-revert-mode activate-bool)
      (diminish 'auto-revert-mode)
      (setq
       display-time-24hr-format             activate-bool
       global-auto-revert-non-file-buffers  activate-bool
       next-line-add-newlines               activate-bool
       kill-whole-line                      activate-bool
       vc-follow-symlinks                   activate-bool
       search-highlight                     activate-bool
       query-replace-highlight              activate-bool
       auto-revert-verbose                  (not activate-bool)
       confirm-nonexistent-file-or-buffer   (not activate-bool))

      ;; TODO: this was determined to have a bug in it. Handle the bug
      ;;(setq revert-buffer-function (if (esc-mode-enabledp)
      ;;                                 'revert-buffer-keep-undo
      ;;                               'revert-buffer))

      ;; TODO: clean up this garbage (but keep functionality)
      ;;   - possibility: wrap with 'ignore-errors
      (if (<= emacs-major-version 23)
          (message "Old Emacs prevents visual-line-mode, auto-complete-mode")
        (global-visual-line-mode activate) ;word wrap by default
        (diminish 'visual-line-mode)
        (after 'auto-complete
          (global-auto-complete-mode activate))) ;in all buffers

      (after 'undo-tree-autoloads
        (global-undo-tree-mode activate)
        (setq undo-tree-visualizer-timestamps t
              undo-tree-visualizer-relative-timestamps t))

      ;; less clutter on the mode line
      ;; TODO - why the fuck did this stop working???? time to bisect
      ;; (mapc (lambda (dim) (after (car dim) (diminish-or-restore (cdr dim))))
      ;;    '((abbrev           . abbrev-mode)
      ;;      (autopair         . autopair-mode)
      ;;      (auto-complete    . auto-complete-mode)
      ;;      (fic-mode         . fic-mode)
      ;;      (enh-ruby-mode    . enh-ruby-mode)
      ;;      (smerge-mode      . smerge-mode)
      ;;      (git-gutter+-mode . git-gutter+-mode)
      ;;      (org-indent       . org-indent-mode)
      ;;      (undo-tree        . undo-tree-mode)))
      ))
#+END_SRC
#+NAME: activate esc-mode-hook
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (add-hook 'esc-mode-hook 'esc/accompanying-mode-hook)
#+END_SRC
#+NAME: activate esc-mode
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (esc-mode 1)
  ;(diminish-or-restore 'esc-mode) ;in the background
#+END_SRC
#+NAME: esc provides
#+BEGIN_SRC emacs-lisp :tangle site-lisp/esc-lisp/esc-mode.el
  (provide 'esc-mode)
#+END_SRC

* Fin
#+BEGIN_SRC emacs-lisp :tangle yes
  (message "All done, %s%s" (user-login-name) ".")
  ;;; .emacs.el ends here
#+END_SRC
